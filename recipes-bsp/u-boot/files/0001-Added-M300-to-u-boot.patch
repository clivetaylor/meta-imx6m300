From c695465a73ac27140fe4d82f761af5e8c0ed93ca Mon Sep 17 00:00:00 2001
From: clivetaylor <clive.taylor@megger.com>
Date: Fri, 23 Oct 2015 14:07:24 +0100
Subject: [PATCH] Added M300 to u-boot

---
 board/freescale/mx6m300/1066mhz_4x128mx16.cfg |  42 ++
 board/freescale/mx6m300/1066mhz_4x256mx16.cfg |  42 ++
 board/freescale/mx6m300/800mhz_2x128mx16.cfg  |  42 ++
 board/freescale/mx6m300/800mhz_2x256mx16.cfg  |  42 ++
 board/freescale/mx6m300/800mhz_4x128mx16.cfg  |  42 ++
 board/freescale/mx6m300/800mhz_4x256mx16.cfg  | 164 ++++++
 board/freescale/mx6m300/Makefile              |   9 +
 board/freescale/mx6m300/clocks.cfg            |  61 ++
 board/freescale/mx6m300/ddr-setup.cfg         | 185 ++++++
 board/freescale/mx6m300/imximage.cfg          |  29 +
 board/freescale/mx6m300/mx6m300.c             | 800 ++++++++++++++++++++++++++
 board/freescale/mx6m300/nitrogen6dl.cfg       |  29 +
 board/freescale/mx6m300/nitrogen6dl2g.cfg     |  29 +
 boards.cfg                                    |   1 +
 include/configs/mx6m300.h                     |  61 ++
 include/configs/mx6m300_common.h              | 267 +++++++++
 16 files changed, 1845 insertions(+)
 create mode 100644 board/freescale/mx6m300/1066mhz_4x128mx16.cfg
 create mode 100644 board/freescale/mx6m300/1066mhz_4x256mx16.cfg
 create mode 100644 board/freescale/mx6m300/800mhz_2x128mx16.cfg
 create mode 100644 board/freescale/mx6m300/800mhz_2x256mx16.cfg
 create mode 100644 board/freescale/mx6m300/800mhz_4x128mx16.cfg
 create mode 100644 board/freescale/mx6m300/800mhz_4x256mx16.cfg
 create mode 100644 board/freescale/mx6m300/Makefile
 create mode 100644 board/freescale/mx6m300/clocks.cfg
 create mode 100644 board/freescale/mx6m300/ddr-setup.cfg
 create mode 100644 board/freescale/mx6m300/imximage.cfg
 create mode 100644 board/freescale/mx6m300/mx6m300.c
 create mode 100644 board/freescale/mx6m300/nitrogen6dl.cfg
 create mode 100644 board/freescale/mx6m300/nitrogen6dl2g.cfg
 create mode 100644 include/configs/mx6m300.h
 create mode 100644 include/configs/mx6m300_common.h

diff --git a/board/freescale/mx6m300/1066mhz_4x128mx16.cfg b/board/freescale/mx6m300/1066mhz_4x128mx16.cfg
new file mode 100644
index 0000000..6c68146
--- /dev/null
+++ b/board/freescale/mx6m300/1066mhz_4x128mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x555A7974
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x005A1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
+DATA 4, MX6_MMDC_P0_MDCTL, 0x831A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42720306
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x026F0266
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x4273030A
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02740240
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x45393B3E
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x403A3747
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x40434541
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x473E4A3B
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0011000E
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x000E001B
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x00190015
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x00070018
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/freescale/mx6m300/1066mhz_4x256mx16.cfg b/board/freescale/mx6m300/1066mhz_4x256mx16.cfg
new file mode 100644
index 0000000..bb5716e
--- /dev/null
+++ b/board/freescale/mx6m300/1066mhz_4x256mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x898E7974
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x008E1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
+DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x43040319
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x03040279
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x43040321
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x03030251
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4d434248
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x42413c4d
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x34424543
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x49324933
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001a0017
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x00170027
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x000a001f
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/freescale/mx6m300/800mhz_2x128mx16.cfg b/board/freescale/mx6m300/800mhz_2x128mx16.cfg
new file mode 100644
index 0000000..e005a64
--- /dev/null
+++ b/board/freescale/mx6m300/800mhz_2x128mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x40435323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000017
+DATA 4, MX6_MMDC_P0_MDCTL, 0x83190000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/freescale/mx6m300/800mhz_2x256mx16.cfg b/board/freescale/mx6m300/800mhz_2x256mx16.cfg
new file mode 100644
index 0000000..581d44c
--- /dev/null
+++ b/board/freescale/mx6m300/800mhz_2x256mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x696C5323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x006C1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
+DATA 4, MX6_MMDC_P0_MDCTL, 0x84190000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/freescale/mx6m300/800mhz_4x128mx16.cfg b/board/freescale/mx6m300/800mhz_4x128mx16.cfg
new file mode 100644
index 0000000..1069342
--- /dev/null
+++ b/board/freescale/mx6m300/800mhz_4x128mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x40435323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
+DATA 4, MX6_MMDC_P0_MDCTL, 0x831A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x420F020F
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x01760175
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x41640171
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x015E0160
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x45464B4A
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x49484A46
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x40402E32
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3A3A3231
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x003A003A
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0030002F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x002F0038
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x00270039
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/freescale/mx6m300/800mhz_4x256mx16.cfg b/board/freescale/mx6m300/800mhz_4x256mx16.cfg
new file mode 100644
index 0000000..26f5b8c
--- /dev/null
+++ b/board/freescale/mx6m300/800mhz_4x256mx16.cfg
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2015 Megger Instruments Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * DDR controller setup for:
+ *	Manufacturer:		Alliance
+ *	Device Part No:		AS4C256M16D3-12BIN
+ *	Clock freq:		400MHz
+ *	Density per CS (Gb):	8
+ *	Chip selects:		1
+ *	Number of banks:	8
+ *	Row address:		15
+ *	Column address:		10
+ *	Data bus width:		64
+ */
+//
+//	Core power down control register
+//	(0x021B0004)
+//
+//	MMDC initialisation value
+//
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+//
+//	Timing configuration registers 0, 1 & 2
+//	(0x021B000C-0x021B0014)
+//
+//	Values taken from M300 stress test calibration
+//
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x676352F3
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66D8B63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+//
+//	Core read/write command delay register
+//	(0x021B002C)
+//
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+//
+//	Core out of reset delays register
+//	(0x021B0030)
+//
+DATA 4, MX6_MMDC_P0_MDOR,  0x006B1023
+//
+//	Core ODT Timing Control Regsister
+//	(0x021B0008)
+//
+//	Value taken from M300 stress test calibration
+//
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333040
+//
+//	Core power down controller - this time with 
+//	power down timer chip select bits set
+//	(0x021B0004)
+//
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+//
+//	Core address space partition register (End of CS0)
+//	(0x021B0040)
+//
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
+//
+//	Core control register
+//	(0x021B0000)
+//
+DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
+//
+//	Core special command register sequence to setup CS0
+//	(0x021B001C)
+//	
+//	Commands to DDR on CS0: MR2, MR3, MR1, MR0, ZQ calibration
+//
+//	Values taken from M300 stress test calibration
+//
+DATA 4, MX6_MMDC_P0_MDSCR, 0x02008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x05208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+//
+//	PHY ZQ HW Control Register
+//	(0x021B0800)
+//
+//	Enable one-time and periodic HW ZQ calibration
+//
+//	Removed ZQ_HW_FOR (bit 16) - register was 0xA1390003
+//
+//DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1380003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+//
+//	Core refresh control register
+//	(0x021B0020)
+//
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+//
+//	PHY 0 and PHY 1 ODT Control registers
+//	(0x021B0818 & 0x021B4818)
+//
+//	Values taken from M300 stress test calibration
+//
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00011117
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00011117
+//
+//	Read DQS gating control registers 1 & 2
+//	(0x021B083C-0x021B0840 for PHY0, 0x021B483C-0x021B4840 for PHY1)
+//
+//	Values taken from M300 stress test calibration
+//
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x43380324
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x4278030C
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x03140320
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02480268
+//
+//	Read delay-line configuration
+//	(0x021B0848 for PHY0 & 0x021B4848 for PHY1)
+//
+//	Values taken from M300 stress test calibration
+//
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x484E4E4C
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4E525046
+//
+//	Write delay-line configuration
+//	(0x021B0850 for PHY0 and 0x021B4850 for PHY1)
+//
+//	Values taken from M300 stress test calibration
+//
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x362E2A30
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3630322A
+//
+//	Write levelling delay control registers 
+//	(0x021B080C-0x021B0810 for PHY0 & 0x21B480C-0x021B4810 for PHY1)
+//
+//	Values set from M300 stress test calibration
+//
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x00630079
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x005C0061
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x003B0036
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x00360061
+//
+//	PHY Measurement Unit Register
+//	(0x021B08B8 for PHY0 & 0x021B48B8 for PHY1)
+//
+//	Clear FRC_MSR (force measurement bit 11) for
+//	normal run mode - was 0x00000800
+//
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000000
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000000
+//
+//	Core power down control register
+//	(0x021B0004)
+//
+//	MMDC run value
+//
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+//
+//	Core power saving control and status
+//	(0x021B0404)
+//
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
+//
+//	Core special command register (clear config
+//	bit at end of initialisation)
+//	(0x021B001C)
+//
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
diff --git a/board/freescale/mx6m300/Makefile b/board/freescale/mx6m300/Makefile
new file mode 100644
index 0000000..ef9d915
--- /dev/null
+++ b/board/freescale/mx6m300/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6m300.o
diff --git a/board/freescale/mx6m300/clocks.cfg b/board/freescale/mx6m300/clocks.cfg
new file mode 100644
index 0000000..a9a9ab9
--- /dev/null
+++ b/board/freescale/mx6m300/clocks.cfg
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2015 Megger Instruments Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+/*
+// set the default clock gate to save power 
+DATA 4, CCM_CCGR0, 0x00C03F3F
+DATA 4, CCM_CCGR1, 0x0030FC03
+DATA 4, CCM_CCGR2, 0x0FFFC000
+DATA 4, CCM_CCGR3, 0x3FF00000
+DATA 4, CCM_CCGR4, 0x00FFF300
+DATA 4, CCM_CCGR5, 0x0F0000C3
+DATA 4, CCM_CCGR6, 0x000003FF
+*/
+//
+//	Temporarily enable all clocks
+//
+DATA 4, CCM_CCGR0, 0xFFFFFFFF
+DATA 4, CCM_CCGR1, 0xFFFFFFFF
+DATA 4, CCM_CCGR2, 0xFFFFFFFF
+DATA 4, CCM_CCGR3, 0xFFFFFFFF
+DATA 4, CCM_CCGR4, 0xFFFFFFFF
+DATA 4, CCM_CCGR5, 0xFFFFFFFF
+DATA 4, CCM_CCGR6, 0xFFFFFFFF
+//DATA 4, CCM_CMEOR, 0xFFFFFFFF
+//
+//	Initialise Video/Graphics processor caching
+//	- enable AXI cache for VDOA/VPU/IPU
+//
+DATA 4, MX6_IOMUXC_GPR4, 0xF00000CF
+//
+//	Not sure why, but everyone seems to set these
+//	to 0x007F007F. The reference manual has nothing 
+//	on them.
+//
+//	- set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7
+//
+DATA 4, MX6_IOMUXC_GPR6, 0x007F007F
+DATA 4, MX6_IOMUXC_GPR7, 0x007F007F
+//
+//	CCOSR - Clock Output Source Register
+//
+//	Setup CCM_CCOSR register as follows:
+//		cko1_en  = 1	--> CKO1 enabled
+//		cko1_div = 111  --> divide by 8
+//		cko1_sel = 1011 --> ahb_clk_root
+//
+//	This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+//
+DATA 4, CCM_CCOSR, 0x000000fb
diff --git a/board/freescale/mx6m300/ddr-setup.cfg b/board/freescale/mx6m300/ddr-setup.cfg
new file mode 100644
index 0000000..810728f
--- /dev/null
+++ b/board/freescale/mx6m300/ddr-setup.cfg
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2015 Megger Instruments Limited
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/*
+ * DDR3 settings
+ * MX6Q    ddr is limited to 1066 Mhz	currently 1056 MHz(528 MHz clock),
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6DL   ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6SOLO ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 32 bits	x16/x32
+ */
+//
+//	DRAM Data Strobe Pad control (pads 0-7)
+//	(0x020E04BC-0x020E04D8)
+//
+//	40ohm drive
+//	Differential input set in GRP_DDRMODE_CTL below
+//
+DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS4, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS5, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS6, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS7, 0x00000030
+//
+//	Pad group control registers (Data strobe 0-7)
+//	(0x020E0764 (0), 0x020E0770 (1),
+//	 0x020E0778-0x020E0784 (2-5),
+//	 0x020E078C (6) & 0x020E0748 (7))
+//
+//	40ohm drive
+//
+DATA 4, MX6_IOM_GRP_B0DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B1DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B2DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B3DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B4DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B5DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B6DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B7DS, 0x00000030
+//
+//	Pad group control register Address Strobe
+//	(0x020E074C)
+//
+//	40ohm drive
+//
+DATA 4, MX6_IOM_GRP_ADDDS, 0x00000030
+//
+//	Pad group control register CTLDS
+//	(0x020E076C)
+//
+//	40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe
+//
+DATA 4, MX6_IOM_GRP_CTLDS, 0x00000030
+//
+//	DRAM Data pad control registers (0-7)
+//	(0x020E0470 - 0x020E048C)
+//
+//	40ohm drive, differential input mode set
+//	in group control register - changed to CMOS
+//
+DATA 4, MX6_IOM_DRAM_DQM0, 0x00000030
+DATA 4, MX6_IOM_DRAM_DQM1, 0x00000030
+DATA 4, MX6_IOM_DRAM_DQM2, 0x00000030
+DATA 4, MX6_IOM_DRAM_DQM3, 0x00000030
+DATA 4, MX6_IOM_DRAM_DQM4, 0x00000030
+DATA 4, MX6_IOM_DRAM_DQM5, 0x00000030
+DATA 4, MX6_IOM_DRAM_DQM6, 0x00000030
+DATA 4, MX6_IOM_DRAM_DQM7, 0x00000030
+//
+//	40ohm drive, CMOS input for CAS/RAS
+//	(0x020E0464 - CAS, 0x020E0490 - RAS)
+//
+DATA 4, MX6_IOM_DRAM_CAS, 0x00000030
+DATA 4, MX6_IOM_DRAM_RAS, 0x00000030
+//
+//	40ohm drive, differential input for SDCLKn
+//	(0x020E04AC-0x020E04B0)
+//
+DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDCLK_1, 0x00000030
+//
+//	Reset pad control register
+//	(0x020E0494)
+//
+//	40ohm drive, CMOS input
+//
+DATA 4, MX6_IOM_DRAM_RESET,  0x00000030
+//
+//	Clock enable pad control registers (1 per CS)
+//	(0x020E04A4 & 0x020E04A8)
+//
+//	Value is as per reset (and shown as reserved in reference manual)
+//
+DATA 4, MX6_IOM_DRAM_SDCKE0, 0x00003000
+DATA 4, MX6_IOM_DRAM_SDCKE1, 0x00003000
+//
+//	On-die termination pad control register (1 per CS)
+//	(0x020E04B4 & 0x020E04B8)
+//
+//	Value taken from M300 stress test calibration
+//
+DATA 4, MX6_IOM_DRAM_SDODT0, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDODT1, 0x00000030
+//
+//	DDR mode control group control register
+//	(0x020E0750)
+//
+//	Differential input mode for pad group
+//
+DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
+//
+//	DDR mode group control register
+//	(0x020E0760)
+//
+//	Differential input mode for pad group
+//
+DATA 4, MX6_IOM_GRP_DDRMODE, 0x00000000
+//
+//	DDR Pullup/keeper pad group control
+//	(0x020E0754)
+//
+//	Disable ddr pullups
+//
+DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
+//
+//	SDBA2 Pad control register
+//	(0x020E04A0)
+//
+//	DSE configured via MX6_IOM_GRP_CTLDS above
+//
+DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
+//
+//	DDR Type control register
+//	(0x020E0774)
+//
+//	Set to DDR3
+//
+DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000C0000
+//
+//	Read DQ byte 0-3 delay registers, 1 per PHY
+//	(0x021B081C-0x021B0828 and 0x021B481C-0x021B4828)
+//
+//	Recommended default values
+//
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY3DL, 0x33333333
+//
+//	Core Miscellaneous register
+//	(0x021B0018)
+//
+//	See note on RALAT value (5) in M300 stress test script file
+//
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00011740
+//
+//	Core special command register
+//	(0x021B001C)
+//
+//	Set config request bit before DDR set up
+//	- set up continues in DRAM type specific
+//	file (800mhz_4x256mx16.cfg in our case)
+//
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
diff --git a/board/freescale/mx6m300/imximage.cfg b/board/freescale/mx6m300/imximage.cfg
new file mode 100644
index 0000000..d0e7d33
--- /dev/null
+++ b/board/freescale/mx6m300/imximage.cfg
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Megger Instruments Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      sd
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#include "ddr-setup.cfg"
+#include "800mhz_4x256mx16.cfg"
+#include "clocks.cfg"
diff --git a/board/freescale/mx6m300/mx6m300.c b/board/freescale/mx6m300/mx6m300.c
new file mode 100644
index 0000000..aa263bf
--- /dev/null
+++ b/board/freescale/mx6m300/mx6m300.c
@@ -0,0 +1,800 @@
+/*
+ * Copyright (C) 2015, Megger Instruments, Ltd
+ *
+ * Author: Clive Taylor <clive.taylor@megger.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+		      PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+static void init_status_leds ( void );
+static void show_status_leds ( int stat );
+//int  board_video_skip ( int Default );
+static void setup_display ( int DoLVDS );
+
+int dram_init(void)
+{
+	//gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
+	gd->ram_size = (phys_size_t)CONFIG_DDR_MB * 1024 * 1024;
+
+	return 0;
+}
+
+#define TEST_IO_PIN1	IMX_GPIO_NR(1,2)
+#define TEST_IO_PIN2	IMX_GPIO_NR(1,3)
+#define TEST_IO_PIN3	IMX_GPIO_NR(1,16)
+#define TEST_IO_PIN4	IMX_GPIO_NR(1,17)
+#define TEST_IO_PIN5	IMX_GPIO_NR(1,18)
+#define TEST_IO_PIN6	IMX_GPIO_NR(1,19)
+#define TEST_IO_PIN7	IMX_GPIO_NR(2,23)
+
+iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_SD3_DAT6__UART1_RX_DATA   | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_SD3_DAT7__UART1_TX_DATA   | MUX_PAD_CTRL(UART_PAD_CTRL),
+	//MX6_PAD_SD3_DAT0__UART1_CTS_B     | MUX_PAD_CTRL(UART_PAD_CTRL),
+	//MX6_PAD_SD3_DAT1__UART1_RTS_B	  | MUX_PAD_CTRL(UART_PAD_CTRL),
+	//MX6_PAD_GPIO_2__GPIO1_IO02	  | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const uart4_pads[] = {
+	MX6_PAD_CSI0_DAT12__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT13__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	/*
+	MX6_PAD_CSIO_DAT16__UART4_CTS_B   | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSIO_DAT17__UART4_RTS_B	  | MUX_PAD_CTRL(UART_PAD_CTRL),
+	*/
+};
+
+iomux_v3_cfg_t const uart5_pads[] = {
+	MX6_PAD_CSI0_DAT14__UART5_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT15__UART5_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	/*
+	MX6_PAD_CSIO_DAT18__UART5_CTS_B   | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSIO_DAT19__UART5_RTS_B	  | MUX_PAD_CTRL(UART_PAD_CTRL),
+	*/
+};
+
+iomux_v3_cfg_t const enet_pads[] = {
+	MX6_PAD_ENET_TXD0__ENET_TX_DATA0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_TXD1__ENET_TX_DATA1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_TX_EN__ENET_TX_EN   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_RXD0__ENET_RX_DATA0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_RXD1__ENET_RX_DATA1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_CRS_DV__ENET_RX_EN  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC       | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDIO__ENET_MDIO     | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_RX_ER__ENET_RX_ER   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO_16__ENET_REF_CLK    | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	
+#if 0
+	MX6_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TXC__RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD0__RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD1__RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD2__RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD3__RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RXC__RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD0__RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD1__RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/* AR8031 PHY Reset */
+	MX6_PAD_ENET_CRS_DV__GPIO1_IO25		| MUX_PAD_CTRL(NO_PAD_CTRL),
+#endif	// 0
+};
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
+#if 0
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(1, 25) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 25), 1);
+#endif // 0
+}
+
+iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__SD2_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__SD2_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT0__SD2_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT1__SD2_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT2__SD2_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT3__SD2_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/*
+	MX6_PAD_NANDF_D4__SD2_DATA4	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D5__SD2_DATA5	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D6__SD2_DATA6	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D7__SD2_DATA7	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	*/
+	MX6_PAD_GPIO_4__GPIO1_IO04	| MUX_PAD_CTRL(NO_PAD_CTRL), /* Card Detect */
+};
+
+iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_ALE__SD4_RESET | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_KEY_COL0__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_COL1__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_ROW0__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_ROW1__GPIO4_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+//
+//	init_status_leds
+//
+//	Set the GPIO direction for the status LEDs and set the multiplexor 
+//	state for LED D7 (on GPIO2_IO23). The pins for GPIO1_IOxx are all
+//	correctly multiplexed by default.
+//
+//	All GPIOs used here are initialised to 1 as the LEDs are active low
+//
+static void
+init_status_leds ( )
+{
+	//
+	//	Set IOMUX for GPIO1 Pins
+	//
+	imx_iomux_v3_setup_pad ( MX6_PAD_GPIO_2__GPIO1_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	imx_iomux_v3_setup_pad ( MX6_PAD_GPIO_3__GPIO1_IO03 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	imx_iomux_v3_setup_pad ( MX6_PAD_SD1_DAT0__GPIO1_IO16 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	imx_iomux_v3_setup_pad ( MX6_PAD_SD1_DAT1__GPIO1_IO17 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	imx_iomux_v3_setup_pad ( MX6_PAD_SD1_CMD__GPIO1_IO18 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	imx_iomux_v3_setup_pad ( MX6_PAD_SD1_DAT2__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	//
+	//	Set IOMUX for EIM_CS0_B to GPIO2_IO23
+	//
+	imx_iomux_v3_setup_pad ( MX6_PAD_EIM_CS0__GPIO2_IO23 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	//
+	//	Set direction of GPIO2_IO23 to output, and set it high (LED off)
+	//
+	gpio_direction_output ( TEST_IO_PIN7, 1 );
+	//
+	//	Set direction of GPIO1_IO02, _IO03, _IO16, _IO17, _IO18, _IO19 to
+	//	outputs, and set all high (LEDs off)
+	//
+	gpio_direction_output ( TEST_IO_PIN1, 1 );
+	gpio_direction_output ( TEST_IO_PIN2, 1 );
+	gpio_direction_output ( TEST_IO_PIN3, 1 );
+	gpio_direction_output ( TEST_IO_PIN4, 1 );
+	gpio_direction_output ( TEST_IO_PIN5, 1 );
+	gpio_direction_output ( TEST_IO_PIN6, 1 );
+}
+
+//
+//	show_status_leds
+//
+//	Display the current step as a 7 bit binary code on the status LEDs
+//
+//	Not very efficient code, but only there for debugging of u-boot
+//
+//	Parameter:
+//		stat	Value to be represented (up to 127)
+//
+static void
+show_status_leds ( int stat )
+{
+	//
+	//	Set/clear LED (D13)
+	//
+	if ( stat && 1 )
+		gpio_set_value ( TEST_IO_PIN1, 0 );
+	else
+		gpio_set_value ( TEST_IO_PIN1, 1 );
+	//
+	//	Set/clear LED (D12)
+	//
+	if ( stat && 2 )
+		gpio_set_value ( TEST_IO_PIN2, 0 );
+	else
+		gpio_set_value ( TEST_IO_PIN2, 1 );
+	//
+	//	Set/clear LED (D11)
+	//
+	if ( stat && 4 )
+		gpio_set_value ( TEST_IO_PIN3, 0 );
+	else
+		gpio_set_value ( TEST_IO_PIN3, 1 );
+	//
+	//	Set/clear LED (D10)
+	//
+	if ( stat && 8 )
+		gpio_set_value ( TEST_IO_PIN4, 0 );
+	else
+		gpio_set_value ( TEST_IO_PIN4, 1 );
+	//
+	//	Set/clear LED (D9)
+	//
+	if ( stat && 0x10 )
+		gpio_set_value ( TEST_IO_PIN5, 0 );
+	else
+		gpio_set_value ( TEST_IO_PIN5, 1 );
+	//
+	//	Set/clear LED (D8)
+	//
+	if ( stat && 0x20 )
+		gpio_set_value ( TEST_IO_PIN6, 0 );
+	else
+		gpio_set_value ( TEST_IO_PIN6, 1 );
+	//
+	//	Set/clear LED (D7)
+	//
+	if ( stat && 0x40 )
+		gpio_set_value ( TEST_IO_PIN7, 0 );
+	else
+		gpio_set_value ( TEST_IO_PIN7, 1 );
+
+}
+
+static void setup_spi(void)
+{
+	/*
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	*/
+}
+
+iomux_v3_cfg_t const di0_pads[] = {
+	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,	/* DISP0_CLK */
+	MX6_PAD_DI0_PIN2__IPU1_DI0_PIN02,		/* DISP0_HSYNC */
+	MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03,		/* DISP0_VSYNC */
+};
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+	//__raw_writel( 2, 0x20E08FC );
+
+	imx_iomux_v3_setup_multiple_pads(uart4_pads, ARRAY_SIZE(uart4_pads));
+	imx_iomux_v3_setup_multiple_pads(uart5_pads, ARRAY_SIZE(uart5_pads));
+
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[2] = { {USDHC2_BASE_ADDR},
+				      {USDHC4_BASE_ADDR} };
+
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(1, 4)
+#define USDHC4_CD_GPIO	IMX_GPIO_NR(6, 8)
+
+int 
+board_mmc_getcd ( struct mmc *mmc )
+{
+	struct fsl_esdhc_cfg 	*cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int 			ret  = 0;
+
+	switch ( cfg->esdhc_base ) {
+		case USDHC2_BASE_ADDR :	ret = 1; // uSDHC2 is always present on Mithras M300 
+					/*
+					ret = !gpio_get_value(USDHC2_CD_GPIO);
+					*/
+					break;
+		case USDHC4_BASE_ADDR :	ret = !gpio_get_value(USDHC4_CD_GPIO);
+					/* uSDHC4 can be present/not present on Mithras M300 */
+					break;
+		}
+
+	return ret;
+}
+
+int 
+board_mmc_init ( bd_t *bis )
+{
+	s32 status = 0;
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD2 (on module)
+	 * mmc1                    SD4 (on carrier/instrument)
+	 */
+	for ( i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++ ) {
+		switch (i) {
+			case 0:	imx_iomux_v3_setup_multiple_pads ( usdhc2_pads, 
+								   ARRAY_SIZE(usdhc2_pads) );
+				gpio_direction_input(USDHC2_CD_GPIO);
+				usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+				usdhc_cfg[0].max_bus_width = 4;
+				break;
+			case 1:	imx_iomux_v3_setup_multiple_pads ( usdhc4_pads, 
+								   ARRAY_SIZE(usdhc4_pads) );
+				gpio_direction_input(USDHC4_CD_GPIO);
+				usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+				usdhc_cfg[1].max_bus_width = 8;
+				break;
+			default:printf ( "Warning: you configured more USDHC controllers"
+			       		 "(%d) than supported by the board (%d)\n",
+			       		 i + 1,
+					 CONFIG_SYS_FSL_USDHC_NUM );
+				return status;
+			}
+		status |= fsl_esdhc_initialize ( bis, &usdhc_cfg[i] );
+		printf ( "Initialising SD card %d: status = %d\n", i, status );
+		}
+
+	return status;
+}
+#endif
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	printf ( "Initialising FEC and PHY. Phy is :%s/n", phydev->drv->name );
+#if 0
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+#endif // 0
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+struct display_info_t {
+	int	bus;
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev);
+	struct	fb_videomode mode;
+};
+
+static int detect_hdmi(struct display_info_t const *dev)
+{
+	struct hdmi_regs *hdmi	= (struct hdmi_regs *)HDMI_ARB_BASE_ADDR;
+	return readb(&hdmi->phy_stat0) & HDMI_DVI_STAT;
+}
+
+
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+static void
+enable_rgb ( struct display_info_t const *dev )
+{
+}
+
+static void enable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)
+				IOMUXC_BASE_ADDR;
+	u32 reg = readl(&iomux->gpr[2]);
+	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT |
+	       IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT;
+	writel(reg, &iomux->gpr[2]);
+}
+
+//
+//	setup_iomux_lcd
+//
+//	Set the IO parallel RGB pin setup in the IOMUX controller
+//
+//	Note that production versions will need to control the backlight,
+//	possibly through PWM for brightness control or GPIO as simple 
+//	On/Off control.
+//
+void 
+setup_iomux_lcd ( void )
+{
+	static const iomux_v3_cfg_t lcd_pads[] = {
+		MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,	// Pixel clock
+		MX6_PAD_DI0_PIN15__IPU1_DI0_PIN15,		// Display enable
+		MX6_PAD_DI0_PIN2__IPU1_DI0_PIN02,		// HSync
+		MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03,		// VSync
+		MX6_PAD_DISP0_DAT0__IPU1_DISP0_DATA00,		// B 0
+		MX6_PAD_DISP0_DAT1__IPU1_DISP0_DATA01,		// B 1
+		MX6_PAD_DISP0_DAT2__IPU1_DISP0_DATA02,		// B 2
+		MX6_PAD_DISP0_DAT3__IPU1_DISP0_DATA03,		// B 3
+		MX6_PAD_DISP0_DAT4__IPU1_DISP0_DATA04,		// B 4
+		MX6_PAD_DISP0_DAT5__IPU1_DISP0_DATA05,		// B 5
+		MX6_PAD_DISP0_DAT6__IPU1_DISP0_DATA06,		// B 6
+		MX6_PAD_DISP0_DAT7__IPU1_DISP0_DATA07,		// B 7
+		MX6_PAD_DISP0_DAT8__IPU1_DISP0_DATA08,		// G 0
+		MX6_PAD_DISP0_DAT9__IPU1_DISP0_DATA09,		// G 1
+		MX6_PAD_DISP0_DAT10__IPU1_DISP0_DATA10,		// G 2
+		MX6_PAD_DISP0_DAT11__IPU1_DISP0_DATA11,		// G 3
+		MX6_PAD_DISP0_DAT12__IPU1_DISP0_DATA12,		// G 4
+		MX6_PAD_DISP0_DAT13__IPU1_DISP0_DATA13,		// G 5
+		MX6_PAD_DISP0_DAT14__IPU1_DISP0_DATA14,		// G 6
+		MX6_PAD_DISP0_DAT15__IPU1_DISP0_DATA15,		// G 7
+		MX6_PAD_DISP0_DAT16__IPU1_DISP0_DATA16,		// R 0
+		MX6_PAD_DISP0_DAT17__IPU1_DISP0_DATA17,		// R 1
+		MX6_PAD_DISP0_DAT18__IPU1_DISP0_DATA18,		// R 2
+		MX6_PAD_DISP0_DAT19__IPU1_DISP0_DATA19,		// R 3
+		MX6_PAD_DISP0_DAT20__IPU1_DISP0_DATA20,		// R 4
+		MX6_PAD_DISP0_DAT21__IPU1_DISP0_DATA21,		// R 5
+		MX6_PAD_DISP0_DAT22__IPU1_DISP0_DATA22,		// R 6
+		MX6_PAD_DISP0_DAT23__IPU1_DISP0_DATA23,		// R 7
+	};
+
+	imx_iomux_v3_setup_multiple_pads ( lcd_pads, ARRAY_SIZE(lcd_pads) );
+#if 0
+
+	/* Turn on GPIO backlight */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D24__GPIO3_24);
+	gpio_direction_output(MX6LOCO_LCD_POWER, 1);
+
+	/* Turn on display contrast */
+	imx_iomux_v3_setup_pad(MX6_PAD_GPIO_1__GPIO1_1);
+	gpio_direction_output(IMX_GPIO_NR(1, 1), 1);
+#endif // 0
+}
+
+
+static struct display_info_t const displays[] = {
+{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= enable_rgb,
+	.mode	= {
+		.name           = "Parallel RGB",
+		.refresh        = 60,
+		.xres           = 480,
+		.yres           = 272,
+		.pixclock       = 111111,	// Set to 9MHz
+		.left_margin    = 40,		// Horizontal Back Porch
+		.right_margin   = 5,		// Horizontal Front Porch
+		.upper_margin   = 8,		// Vertical Back Porch
+		.lower_margin   = 8,		// Vertical Front Porch
+		.hsync_len      = 1,		// Pulse width in clocks
+		.vsync_len      = 2,		// Pulse width in clocks
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} },
+{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= enable_lvds,
+	.mode	= {
+		/*
+		 * For Kyocera TCG070WVLQEPNN-AN20:
+		 *	Dot Clk  = 33.2MHz
+		 *	H-active = 800 pixels
+		 *	H-total  = 1056 (so 256 pixels of blanking + sync)
+		 *	H-period = 31.8us
+		 *	V-active = 480 lines
+		 *	V-total  = 525 (so 45 lines of blanking + sync)
+		 *	Refresh  = 60Hz
+		 */
+		.name           = "LVDS RGB Display",
+		.refresh        = 60,
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 30120, //ps - 33.2MHz,
+		.left_margin    = 84,    //Adjust to centre
+		.right_margin   = 84,    // image horizontally
+		.upper_margin   = 20,    //Adjust to centre
+		.lower_margin   = 20,    //  image vertically
+		.hsync_len      = 88,	 //using VESA's 8% rule
+		.vsync_len      = 5,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_LVDS666,
+	.detect	= detect_hdmi,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int 
+board_video_skip ( void ) //int Default )
+{
+	int i;
+	int ret;
+	int Default = 1;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			struct display_info_t const *dev = displays+i;
+			if (dev->detect && dev->detect(dev)) {
+				panel = dev->mode.name;
+				printf("auto-detected panel %s\n", panel);
+				break;
+			}
+		}
+		if (!panel) {
+			i = Default;
+			panel = displays[i].mode.name;
+			printf("No panel detected: default to %s\n", panel);
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = ipuv3_fb_init(&displays[i].mode, 0,
+				    displays[i].pixfmt);
+		if (!ret) {
+			displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void
+setup_display ( int DoLVDS )
+{
+
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+	
+	printf ( "Entering setup_display, DoLVDS = %d\n", DoLVDS );
+	if ( DoLVDS ) {	
+		//
+		//	HSync, VSync and Dot clock already set up
+		//
+		/* Setup HSYNC, VSYNC, DISP_CLK for debugging purposes */
+		imx_iomux_v3_setup_multiple_pads(di0_pads, ARRAY_SIZE(di0_pads));
+		}
+
+	enable_ipu_clock();
+#if 0
+	//
+	//	M300 has no HDMI output
+	//
+	imx_setup_hdmi();
+#endif	// 0
+	if ( !DoLVDS ) {
+		reg = readl(&mxc_ccm->chsccdr);
+		reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+			<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+		writel(reg, &mxc_ccm->chsccdr);
+		}
+	else {
+		/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+		reg = readl(&mxc_ccm->CCGR3);
+		reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK;
+		writel(reg, &mxc_ccm->CCGR3);
+
+		/* set LDB0, LDB1 clk select to 011/011 */
+		reg = readl(&mxc_ccm->cs2cdr);
+		reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+			 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+		reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+		      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+		writel(reg, &mxc_ccm->cs2cdr);
+
+		reg = readl(&mxc_ccm->cscmr2);
+		reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
+		writel(reg, &mxc_ccm->cscmr2);
+
+		reg = readl(&mxc_ccm->chsccdr);
+		reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+			<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+		writel(reg, &mxc_ccm->chsccdr);
+
+		reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+		     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_HIGH
+		     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_HIGH
+		     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+		     | IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT
+		     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+		     | IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT
+		     | IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED
+		     | IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
+		writel(reg, &iomux->gpr[2]);
+
+		reg = readl(&iomux->gpr[3]);
+		reg = (reg & ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK
+				| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+				    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+			       << IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
+		writel(reg, &iomux->gpr[3]);
+		}
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+
+	return cpu_eth_init(bis);
+}
+
+int board_early_init_f(void)
+{
+	int	LVDSVideo = 1;
+
+	init_status_leds ( );
+	show_status_leds ( 1 );
+
+	setup_iomux_uart();
+	if ( !LVDSVideo )
+		setup_iomux_lcd ( );
+
+	show_status_leds ( 2 );
+#if 0
+	gpio_direction_output ( TEST_IO_PIN, 1 );
+	while ( 1 ) {
+		gpio_set_value ( TEST_IO_PIN, 1 );
+		udelay ( 1000000 );
+		gpio_set_value ( TEST_IO_PIN, 0 );
+		udelay ( 1000000 );
+		}
+#endif	// 0
+
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display ( 1 );
+	show_status_leds ( 3 );
+#endif
+
+	return 0;
+}
+
+
+
+int board_init(void)
+{
+	//init_status_leds ( );
+	show_status_leds ( 4 );
+
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_MXC_SPI
+	setup_spi();
+#endif
+	show_status_leds ( 5 );
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	/* No SD3 on Mithras M300
+	{"sd3",	 MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	*/
+	/* 8 bit bus width */
+	{"mmc1", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+
+#ifdef CONFIG_CMD_BMODE
+	show_status_leds ( 6 );
+	add_board_boot_modes(board_boot_modes);
+	show_status_leds ( 7 );
+#endif
+
+	return 0;
+}
+
+
+
+int checkboard(void)
+{
+	puts("Board: Mithras MX6M300DL\n");
+	return 0;
+}
diff --git a/board/freescale/mx6m300/nitrogen6dl.cfg b/board/freescale/mx6m300/nitrogen6dl.cfg
new file mode 100644
index 0000000..1cdccad
--- /dev/null
+++ b/board/freescale/mx6m300/nitrogen6dl.cfg
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#include "ddr-setup.cfg"
+#include "800mhz_4x128mx16.cfg"
+#include "clocks.cfg"
diff --git a/board/freescale/mx6m300/nitrogen6dl2g.cfg b/board/freescale/mx6m300/nitrogen6dl2g.cfg
new file mode 100644
index 0000000..516d67e
--- /dev/null
+++ b/board/freescale/mx6m300/nitrogen6dl2g.cfg
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#include "ddr-setup.cfg"
+#include "800mhz_4x256mx16.cfg"
+#include "clocks.cfg"
diff --git a/boards.cfg b/boards.cfg
index a8336cc..f96991f 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -303,6 +303,7 @@ Active  arm         armv7          mx6         boundary        nitrogen6x
 Active  arm         armv7          mx6         boundary        nitrogen6x          nitrogen6s                           nitrogen6x:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s.cfg,MX6S,DDR_MB=512                                                    Eric Nelson <eric.nelson@boundarydevices.com>
 Active  arm         armv7          mx6         boundary        nitrogen6x          nitrogen6s1g                         nitrogen6x:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s1g.cfg,MX6S,DDR_MB=1024                                                 Eric Nelson <eric.nelson@boundarydevices.com>
 Active  arm         armv7          mx6         congatec        cgtqmx6eval         cgtqmx6qeval                         cgtqmx6eval:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg,MX6Q                                                          Leo Sartre <lsartre@adeneo-embedded.com>
+Active  arm         armv7          mx6         freescale       mx6m300             mx6m300                            mx6m300:IMX_CONFIG=board/freescale/mx6m300/imximage.cfg,MX6DL,DEFAULT_FDT_FILE="mx6m300.dtb",DDR_MB=2048
 Active  arm         armv7          mx6         freescale       mx6qarm2            mx6qarm2                             mx6qarm2:IMX_CONFIG=board/freescale/mx6qarm2/imximage.cfg                                                                         Jason Liu <r64343@freescale.com>
 Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreauto                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q                                                          Fabio Estevam <fabio.estevam@freescale.com>
 Active  arm         armv7          mx6         freescale       mx6sabresd          mx6dlsabresd                         mx6sabresd:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl.cfg,MX6DL                                                             Fabio Estevam <fabio.estevam@freescale.com>
diff --git a/include/configs/mx6m300.h b/include/configs/mx6m300.h
new file mode 100644
index 0000000..674883d
--- /dev/null
+++ b/include/configs/mx6m300.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2015 Megger Instruments, Ltd
+ *
+ * Configuration settings for the Mithras M300 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6M300_CONFIG_H
+#define __MX6M300_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV	"ttymxc0"
+#define CONFIG_MMCROOT		"/dev/mmcblk0p1"
+/*
+#if defined(CONFIG_MX6Q)
+#define CONFIG_DEFAULT_FDT_FILE	"imx6q-sabresd-ldo.dtb"
+#elif defined(CONFIG_MX6DL)
+#define CONFIG_DEFAULT_FDT_FILE	"imx6dl-sabresd-ldo.dtb"
+#endif
+*/
+//
+//	M300 has 2GB DDR3
+//
+#define PHYS_SDRAM_SIZE		(2u * 1024 * 1024 * 1024)
+
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#include "mx6m300_common.h"
+//
+//	2 SDHC Devices (SDHC2 and SDHC4), default boot from SDHC2
+//
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0	/* SDHC2 */
+#endif
+
+/* Framebuffer */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+//
+//	Want serial as default console
+//
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IPUV3_CLK 260000000
+#define CONFIG_IMX_HDMI
+
+#endif                         /* __MX6M300_CONFIG_H */
diff --git a/include/configs/mx6m300_common.h b/include/configs/mx6m300_common.h
new file mode 100644
index 0000000..e22b600
--- /dev/null
+++ b/include/configs/mx6m300_common.h
@@ -0,0 +1,267 @@
+/*
+ * Copyright (C) 2015, Megger Instruments, Ltd.
+ *
+ * Configuration settings for the Mithras M300 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6M300_COMMON_CONFIG_H
+#define __MX6M300_COMMON_CONFIG_H
+
+#define CONFIG_MX6
+
+#include "mx6_common.h"
+#include <asm/sizes.h>
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME			"FEC"
+#define CONFIG_FEC_MXC_PHYADDR		0
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+
+//#define CONFIG_CMD_SF
+#ifdef CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		(0 | (IMX_GPIO_NR(4, 9) << 8))
+#define CONFIG_SF_DEFAULT_SPEED		20000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX              1
+#define CONFIG_BAUDRATE                115200
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_BMODE
+#define CONFIG_CMD_BOOTZ
+#define CONFIG_CMD_SETEXPR
+//
+//	Enable memory test command, mtest
+//
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_ALT_MEMTEST
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY               10
+
+#define CONFIG_LOADADDR                0x12000000
+#define CONFIG_SYS_TEXT_BASE           0x17800000
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+#define EMMC_ENV \
+	"emmcdev=2\0" \
+	"update_emmc_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+			"if mmc dev ${emmcdev} && " \
+				"mmc open ${emmcdev} 1; then "	\
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+				"mmc close ${emmcdev} 1; " \
+			"fi; "	\
+		"fi\0"
+#else
+#define EMMC_ENV ""
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"uimage=uImage\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONFIG_CONSOLE_DEV "\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"update_sd_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if mmc dev ${mmcdev}; then "	\
+			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0" \
+	EMMC_ENV	  \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loaduimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${uimage}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootm; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootm; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${uimage}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootm; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootm; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev ${mmcdev};" \
+	"if mmc rescan; then " \
+		"if run loadbootscript; then " \
+		"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run netboot; " \
+			"fi; " \
+		"fi; " \
+	"else run netboot; fi"
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2     "Mithras M300> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE              256
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS             16
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE               (128 * 1024)
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_ENV_IS_IN_MMC
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(6 * 64 * 1024)
+#endif
+
+#define CONFIG_OF_LIBFDT
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#endif                         /* __MX6M300_COMMON_CONFIG_H */
-- 
1.9.1

