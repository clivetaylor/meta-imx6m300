From c44bd2cb76268153b91c522697df0f1e63c5dc19 Mon Sep 17 00:00:00 2001
From: clivetaylor <clive.taylor@megger.com>
Date: Thu, 29 Oct 2015 12:26:50 +0000
Subject: [PATCH] Corrected USB/I2C pin contention.

---
 .../devicetree/bindings/regulator/pfuze100.txt     |   96 +-
 arch/arm/boot/dts/Makefile                         |    3 +
 arch/arm/boot/dts/imx6dl-sabresd-common.dtsi       |  130 ++
 arch/arm/boot/dts/imx6dl-sabresd-pf200.dts         |  126 ++
 arch/arm/boot/dts/imx6dl-sabresd.dts               |  175 +-
 arch/arm/boot/dts/imx6m300-common.dtsi             |   53 +
 arch/arm/boot/dts/imx6m300-dl.dtsi                 |  243 +++
 arch/arm/boot/dts/imx6m300-qdl.dtsi                | 2020 ++++++++++++++++++++
 arch/arm/boot/dts/imx6m300.dts                     |   20 +
 arch/arm/boot/dts/imx6m300.dtsi                    |  545 ++++++
 arch/arm/boot/dts/imx6q-sabresd.dts                |  101 +
 arch/arm/boot/dts/imx6qdl-sabresd.dtsi             |   99 -
 arch/arm/boot/dts/imx6sl-evk-common.dtsi           |  504 +++++
 arch/arm/boot/dts/imx6sl-evk-pf200.dts             |  122 ++
 arch/arm/boot/dts/imx6sl-evk.dts                   |  497 +----
 arch/arm/mach-imx/cpuidle-imx6q.c                  |    5 +-
 arch/arm/mach-imx/gpc.c                            |    8 +-
 arch/arm/mach-imx/platsmp.c                        |    4 +-
 arch/arm/mach-imx/pm-imx6.c                        |   36 +
 drivers/regulator/Kconfig                          |    6 +-
 drivers/regulator/pfuze100-regulator.c             |  187 +-
 include/linux/regulator/pfuze100.h                 |   14 +
 22 files changed, 4244 insertions(+), 750 deletions(-)
 create mode 100644 arch/arm/boot/dts/imx6dl-sabresd-common.dtsi
 create mode 100644 arch/arm/boot/dts/imx6dl-sabresd-pf200.dts
 create mode 100644 arch/arm/boot/dts/imx6m300-common.dtsi
 create mode 100644 arch/arm/boot/dts/imx6m300-dl.dtsi
 create mode 100644 arch/arm/boot/dts/imx6m300-qdl.dtsi
 create mode 100644 arch/arm/boot/dts/imx6m300.dts
 create mode 100644 arch/arm/boot/dts/imx6m300.dtsi
 create mode 100644 arch/arm/boot/dts/imx6sl-evk-common.dtsi
 create mode 100644 arch/arm/boot/dts/imx6sl-evk-pf200.dts

diff --git a/Documentation/devicetree/bindings/regulator/pfuze100.txt b/Documentation/devicetree/bindings/regulator/pfuze100.txt
index fc989b2..34ef5d1 100644
--- a/Documentation/devicetree/bindings/regulator/pfuze100.txt
+++ b/Documentation/devicetree/bindings/regulator/pfuze100.txt
@@ -1,7 +1,7 @@
 PFUZE100 family of regulators
 
 Required properties:
-- compatible: "fsl,pfuze100"
+- compatible: "fsl,pfuze100" or "fsl,pfuze200"
 - reg: I2C slave address
 
 Required child node:
@@ -10,11 +10,14 @@ Required child node:
   Documentation/devicetree/bindings/regulator/regulator.txt.
 
   The valid names for regulators are:
+  --PFUZE100
   sw1ab,sw1c,sw2,sw3a,sw3b,sw4,swbst,vsnvs,vrefddr,vgen1~vgen6
+  --PFUZE200
+  sw1ab,sw2,sw3a,sw3b,swbst,vsnvs,vrefddr,vgen1~vgen6
 
 Each regulator is defined using the standard binding for regulators.
 
-Example:
+Example 1: PFUZE100
 
 	pmic: pfuze100@08 {
 		compatible = "fsl,pfuze100";
@@ -113,3 +116,92 @@ Example:
 			};
 		};
 	};
+
+
+Example 2: PFUZE200
+
+	pmic: pfuze200@08 {
+		compatible = "fsl,pfuze200";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index f43b68b..0bfac5f 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -120,7 +120,9 @@ dtb-$(CONFIG_ARCH_MXC) += \
 	imx6dl-sabresd.dtb \
 	imx6dl-sabresd-hdcp.dtb \
 	imx6dl-sabresd-ldo.dtb \
+	imx6dl-sabresd-pf200.dtb \
 	imx6dl-wandboard.dtb \
+	imx6m300.dtb \
 	imx6q-arm2.dtb \
 	imx6q-sabreauto.dtb \
 	imx6q-sabreauto-ecspi.dtb \
@@ -134,6 +136,7 @@ dtb-$(CONFIG_ARCH_MXC) += \
 	imx6sl-evk.dtb \
 	imx6sl-evk-csi.dtb \
 	imx6sl-evk-ldo.dtb \
+	imx6sl-evk-pf200.dtb \
 	vf610-twr.dtb
 dtb-$(CONFIG_ARCH_MXS) += imx23-evk.dtb \
 	imx23-olinuxino.dtb \
diff --git a/arch/arm/boot/dts/imx6dl-sabresd-common.dtsi b/arch/arm/boot/dts/imx6dl-sabresd-common.dtsi
new file mode 100644
index 0000000..2a07534
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-sabresd-common.dtsi
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&battery {
+	offset-charger = <1485>;
+	offset-discharger = <1464>;
+	offset-usb-charger = <1285>;
+};
+
+&i2c3 {
+	max17135@48 {
+		compatible = "maxim,max17135";
+		reg = <0x48>;
+		vneg_pwrup = <1>;
+		gvee_pwrup = <1>;
+		vpos_pwrup = <2>;
+		gvdd_pwrup = <1>;
+		gvdd_pwrdn = <1>;
+		vpos_pwrdn = <2>;
+		gvee_pwrdn = <1>;
+		vneg_pwrdn = <1>;
+		SENSOR-supply = <&reg_sensor>;
+		gpio_pmic_pwrgood = <&gpio2 21 0>;
+		gpio_pmic_vcom_ctrl = <&gpio3 17 0>;
+		gpio_pmic_wakeup = <&gpio3 20 0>;
+		gpio_pmic_v3p3 = <&gpio2 20 0>;
+		gpio_pmic_intr = <&gpio2 25 0>;
+
+		regulators {
+			DISPLAY_reg: DISPLAY {
+				regulator-name = "DISPLAY";
+			};
+
+			GVDD_reg: GVDD {
+				/* 20v */
+				regulator-name = "GVDD";
+			};
+
+			GVEE_reg: GVEE {
+				/* -22v */
+				regulator-name = "GVEE";
+			};
+
+			HVINN_reg: HVINN {
+				/* -22v */
+				regulator-name = "HVINN";
+			};
+
+			HVINP_reg: HVINP {
+				/* 20v */
+				regulator-name = "HVINP";
+			};
+
+			VCOM_reg: VCOM {
+				regulator-name = "VCOM";
+				/* 2's-compliment, -4325000 */
+				regulator-min-microvolt = <0xffbe0178>;
+				/* 2's-compliment, -500000 */
+				regulator-max-microvolt = <0xfff85ee0>;
+			};
+
+			VNEG_reg: VNEG {
+				/* -15v */
+				regulator-name = "VNEG";
+			};
+
+			VPOS_reg: VPOS {
+				/* 15v */
+				regulator-name = "VPOS";
+			};
+
+			V3P3_reg: V3P3 {
+				regulator-name = "V3P3";
+			};
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>, <&pinctrl_hog_2>;
+
+	hog {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				/* MAX17135 */
+				MX6QDL_PAD_EIM_A17__GPIO2_IO21 0x80000000
+				MX6QDL_PAD_EIM_D17__GPIO3_IO17 0x80000000
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20 0x80000000
+				MX6QDL_PAD_EIM_A18__GPIO2_IO20 0x80000000
+				MX6QDL_PAD_EIM_OE__GPIO2_IO25 0x80000000
+				/* elan touch */
+				MX6QDL_PAD_EIM_A20__GPIO2_IO18 0x80000000
+				MX6QDL_PAD_EIM_DA8__GPIO3_IO08 0x80000000
+				MX6QDL_PAD_EIM_D28__GPIO3_IO28 0x170b0
+			>;
+		};
+	};
+};
+
+&epdc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_epdc_0>;
+	V3P3-supply = <&V3P3_reg>;
+	VCOM-supply = <&VCOM_reg>;
+	DISPLAY-supply = <&DISPLAY_reg>;
+	status = "okay";
+};
+
+&ldb {
+	ipu_id = <0>;
+	sec_ipu_id = <0>;
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&pxp {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/imx6dl-sabresd-pf200.dts b/arch/arm/boot/dts/imx6dl-sabresd-pf200.dts
new file mode 100644
index 0000000..499f7d3
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-sabresd-pf200.dts
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-sabresd.dtsi"
+#include "imx6dl-sabresd-common.dtsi"
+
+/ {
+	model = "Freescale i.MX6 DualLite SABRE Smart Device Board(PFUZE200)";
+	compatible = "fsl,imx6dl-sabresd", "fsl,imx6dl";
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpc {
+	fsl,ldo-bypass = <0>; /* use ldo-bypass, u-boot will check it and configure */
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpu {
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&vpu {
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&i2c2 {
+	pmic: pfuze200@08 {
+		compatible = "fsl,pfuze200";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/imx6dl-sabresd.dts b/arch/arm/boot/dts/imx6dl-sabresd.dts
index 5713c71..b4c738d 100644
--- a/arch/arm/boot/dts/imx6dl-sabresd.dts
+++ b/arch/arm/boot/dts/imx6dl-sabresd.dts
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -10,131 +10,110 @@
 
 #include "imx6dl.dtsi"
 #include "imx6qdl-sabresd.dtsi"
+#include "imx6dl-sabresd-common.dtsi"
 
 / {
-	model = "Freescale i.MX6 DualLite SABRE Smart Device Board";
+	model = "Freescale i.MX6 DualLite SABRE Smart Device Board(PFUZE100)";
 	compatible = "fsl,imx6dl-sabresd", "fsl,imx6dl";
 };
 
-&battery {
-	offset-charger = <1485>;
-	offset-discharger = <1464>;
-	offset-usb-charger = <1285>;
-};
-
-&i2c3 {
-	max17135@48 {
-		compatible = "maxim,max17135";
-		reg = <0x48>;
-		vneg_pwrup = <1>;
-		gvee_pwrup = <1>;
-		vpos_pwrup = <2>;
-		gvdd_pwrup = <1>;
-		gvdd_pwrdn = <1>;
-		vpos_pwrdn = <2>;
-		gvee_pwrdn = <1>;
-		vneg_pwrdn = <1>;
-		SENSOR-supply = <&reg_sensor>;
-		gpio_pmic_pwrgood = <&gpio2 21 0>;
-		gpio_pmic_vcom_ctrl = <&gpio3 17 0>;
-		gpio_pmic_wakeup = <&gpio3 20 0>;
-		gpio_pmic_v3p3 = <&gpio2 20 0>;
-		gpio_pmic_intr = <&gpio2 25 0>;
+&i2c2 {
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
 
 		regulators {
-			DISPLAY_reg: DISPLAY {
-				regulator-name = "DISPLAY";
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
 			};
 
-			GVDD_reg: GVDD {
-				/* 20v */
-				regulator-name = "GVDD";
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
 			};
 
-			GVEE_reg: GVEE {
-				/* -22v */
-				regulator-name = "GVEE";
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
 			};
 
-			HVINN_reg: HVINN {
-				/* -22v */
-				regulator-name = "HVINN";
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
 			};
 
-			HVINP_reg: HVINP {
-				/* 20v */
-				regulator-name = "HVINP";
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
 			};
 
-			VCOM_reg: VCOM {
-				regulator-name = "VCOM";
-				/* 2's-compliment, -4325000 */
-				regulator-min-microvolt = <0xffbe0178>;
-				/* 2's-compliment, -500000 */
-				regulator-max-microvolt = <0xfff85ee0>;
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
 			};
 
-			VNEG_reg: VNEG {
-				/* -15v */
-				regulator-name = "VNEG";
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
 			};
 
-			VPOS_reg: VPOS {
-				/* 15v */
-				regulator-name = "VPOS";
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
 			};
 
-			V3P3_reg: V3P3 {
-				regulator-name = "V3P3";
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
 			};
-		};
-	};
-};
 
-&iomuxc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_hog_1>, <&pinctrl_hog_2>;
-
-	hog {
-		pinctrl_hog_2: hoggrp-2 {
-			fsl,pins = <
-				/* MAX17135 */
-				MX6QDL_PAD_EIM_A17__GPIO2_IO21 0x80000000
-				MX6QDL_PAD_EIM_D17__GPIO3_IO17 0x80000000
-				MX6QDL_PAD_EIM_D20__GPIO3_IO20 0x80000000
-				MX6QDL_PAD_EIM_A18__GPIO2_IO20 0x80000000
-				MX6QDL_PAD_EIM_OE__GPIO2_IO25 0x80000000
-				/* elan touch */
-				MX6QDL_PAD_EIM_A20__GPIO2_IO18 0x80000000
-				MX6QDL_PAD_EIM_DA8__GPIO3_IO08 0x80000000
-				MX6QDL_PAD_EIM_D28__GPIO3_IO28 0x170b0
-			>;
-		};
-	};
-};
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
 
-&epdc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_epdc_0>;
-	V3P3-supply = <&V3P3_reg>;
-	VCOM-supply = <&VCOM_reg>;
-	DISPLAY-supply = <&DISPLAY_reg>;
-	status = "okay";
-};
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
 
-&ldb {
-	ipu_id = <0>;
-	sec_ipu_id = <0>;
-};
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
 
-&mxcfb1 {
-	status = "okay";
-};
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
 
-&mxcfb2 {
-	status = "okay";
-};
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
 
-&pxp {
-	status = "okay";
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
 };
diff --git a/arch/arm/boot/dts/imx6m300-common.dtsi b/arch/arm/boot/dts/imx6m300-common.dtsi
new file mode 100644
index 0000000..1e2685b
--- /dev/null
+++ b/arch/arm/boot/dts/imx6m300-common.dtsi
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2015, Megger Instruments, Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *	EPDC (Electronic Paper Display Controller) - not available on M300
+ *
+&epdc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_epdc_0>;
+	V3P3-supply = <&V3P3_reg>;
+	VCOM-supply = <&VCOM_reg>;
+	DISPLAY-supply = <&DISPLAY_reg>;
+	status = "disabled";
+};
+ */
+
+&ldb {
+	ipu_id = <0>;
+	sec_ipu_id = <0>;
+};
+
+//
+//	LVDS 7" (800x480) Disabled by default on M300
+//
+&mxcfb1 {
+	status = "disabled";
+};
+
+//
+//	HDMI - not available on M300
+//
+&mxcfb2 {
+	status = "disabled";
+};
+
+//
+//	Assume 4.3" parallel RGB as default on M300
+//
+&mxcfb3 {
+	status = "okay";
+};
+
+//
+//	Pixel Pipeline - needs to be enabled for graphics output
+//
+&pxp {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/imx6m300-dl.dtsi b/arch/arm/boot/dts/imx6m300-dl.dtsi
new file mode 100644
index 0000000..97c9093
--- /dev/null
+++ b/arch/arm/boot/dts/imx6m300-dl.dtsi
@@ -0,0 +1,243 @@
+
+/*
+ * Copyright 2015, Megger Instruments, Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains the device layout (pin multiplexing, clock select, etc)
+ * for the SoC on the iMX6DL based M300. 
+ *
+ * Included files:
+ *	imx6dl-pinfunc.h	- Multiplexed pin macros and IOMUX register
+ *				  values for each multiplexed pin
+ *	imx6m300-qdl.dtsi	- Device layout for Quad/Dual/DualLite based M300s
+ */
+
+#include "imx6dl-pinfunc.h"
+#include "imx6m300-qdl.dtsi"
+
+/ {
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a9";
+			device_type = "cpu";
+			reg = <0>;
+			next-level-cache = <&L2>;
+			operating-points = <
+				/* kHz    uV */
+				996000  1275000
+				792000  1175000
+				396000  1075000
+			>;
+			fsl,soc-operating-points = <
+				/* ARM kHz      SOC-PU uV */
+				996000            1175000
+				792000            1175000
+				396000            1175000
+			>;
+			clock-latency = <61036>; /* two CLK32 periods */
+			clocks = <&clks 104>, <&clks 6>, <&clks 16>,
+				 <&clks 17>, <&clks 170>;
+			clock-names = "arm", "pll2_pfd2_396m", "step",
+				      "pll1_sw", "pll1_sys";
+			arm-supply = <&reg_arm>;
+			pu-supply = <&reg_pu>;
+			soc-supply = <&reg_soc>;
+		};
+
+		cpu@1 {
+			compatible = "arm,cortex-a9";
+			device_type = "cpu";
+			reg = <1>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	soc {
+
+		busfreq { /* BUSFREQ */
+			compatible = "fsl,imx6_busfreq";
+			clocks = <&clks 171>, <&clks 6>, <&clks 11>, <&clks 104>, <&clks 172>, <&clks 58>,
+				<&clks 18>, <&clks 60>, <&clks 20>, <&clks 3>, <&clks 22> , <&clks 8>;
+			clock-names = "pll2_bus", "pll2_pfd2_396m", "pll2_198m", "arm", "pll3_usb_otg", "periph",
+				"periph_pre", "periph_clk2", "periph_clk2_sel", "osc", "axi_sel", "pll3_pfd1_540m";
+			interrupts = <0 107 0x04>, <0 112 0x4>;
+			interrupt-names = "irq_busfreq_0", "irq_busfreq_1";
+			fsl,max_ddr_freq = <400000000>;
+		};
+
+		gpu: gpu@00130000 {
+			compatible = "fsl,imx6dl-gpu", "fsl,imx6q-gpu";
+			reg = <0x00130000 0x4000>, <0x00134000 0x4000>,
+			      <0x0 0x0>;
+			reg-names = "iobase_3d", "iobase_2d",
+				    "phys_baseaddr";
+			interrupts = <0 9 0x04>, <0 10 0x04>;
+			interrupt-names = "irq_3d", "irq_2d";
+			clocks = <&clks 143>, <&clks 27>,
+				 <&clks 121>, <&clks 122>,
+				 <&clks 0>;
+			clock-names = "gpu2d_axi_clk", "gpu3d_axi_clk",
+				      "gpu2d_clk", "gpu3d_clk",
+				      "gpu3d_shader_clk";
+			resets = <&src 0>, <&src 3>;
+			reset-names = "gpu3d", "gpu2d";
+			pu-supply = <&reg_pu>;
+		};
+		/*
+		 *	On-Chip RAM (OCRAM)
+		 */
+		ocram: sram@00900000 {
+			compatible = "mmio-sram";
+			reg = <0x00904000 0x1C000>;
+			clocks = <&clks 142>;
+		};
+		/*
+		 *	HDMI - disabled on M300
+		 */
+		hdmi_core: hdmi_core@00120000 {
+			compatible = "fsl,imx6dl-hdmi-core";
+			reg = <0x00120000 0x9000>;
+			clocks = <&clks 124>, <&clks 123>;
+			clock-names = "hdmi_isfr", "hdmi_iahb";
+			status = "disabled";
+		};
+
+		hdmi_video: hdmi_video@020e0000 {
+			compatible = "fsl,imx6dl-hdmi-video";
+			reg =  <0x020e0000 0x1000>;
+			reg-names = "hdmi_gpr";
+			interrupts = <0 115 0x04>;
+			clocks = <&clks 124>, <&clks 123>;
+			clock-names = "hdmi_isfr", "hdmi_iahb";
+			status = "disabled";
+		};
+
+		hdmi_audio: hdmi_audio@00120000 {
+			compatible = "fsl,imx6dl-hdmi-audio";
+			clocks = <&clks 124>, <&clks 123>;
+			clock-names = "hdmi_isfr", "hdmi_iahb";
+			dmas = <&sdma 2 22 0>;
+			dma-names = "tx";
+			status = "disabled";
+		};
+
+		hdmi_cec: hdmi_cec@00120000 {
+			compatible = "fsl,imx6dl-hdmi-cec";
+			interrupts = <0 115 0x04>;
+			status = "disabled";
+		};
+
+		/*
+		 *	Advanced High Speed Bus (AHB) to Internal Peripheral (AIPS) controller
+		 */
+		aips1: aips-bus@02000000 {
+			/*
+			 *	Video Processing Unit (VPU)
+			 */
+			vpu@02040000 {
+				iramsize = <0>;
+				status = "okay";
+			};
+			/*
+			 *	IOMux Controller (IOMUX)
+			 */
+			iomuxc: iomuxc@020e0000 {
+				compatible = "fsl,imx6dl-iomuxc";
+			};
+			/*
+			 *	Pixel Pipeline (PXP)
+			 */
+			pxp: pxp@020f0000 {
+				compatible = "fsl,imx6dl-pxp-dma";
+				reg = <0x020f0000 0x4000>;
+				interrupts = <0 98 0x04>;
+				clocks = <&clks 133>;
+				clock-names = "pxp-axi";
+				status = "disabled";
+			};
+			/*
+			 *	Electronic Paper Device Controller (EPDC)
+			 *	Not used on M300
+			 *
+			epdc: epdc@020f4000 {
+				compatible = "fsl,imx6dl-epdc";
+				reg = <0x020f4000 0x4000>;
+				interrupts = <0 97 0x04>;
+				clocks = <&clks 133>, <&clks 137>;
+				clock-names = "epdc_axi", "epdc_pix";
+				status = "disabled";
+			};
+			 */
+			/*
+			 *	LCD Interface (LCDIF)
+			 */
+			lcdif: lcdif@020f8000 {
+				reg = <0x020f8000 0x4000>;
+				interrupts = <0 39 0x04>;
+			};
+		};
+
+		aips2: aips-bus@02100000 {
+			/*
+			 *	Mobile Industry Processor Interface (MIPI) Display Interface (DSI)
+			 *  Not used in M300
+			 *
+			mipi_dsi: mipi@021e0000 {
+				compatible = "fsl,imx6dl-mipi-dsi";
+				reg = <0x021e0000 0x4000>;
+				interrupts = <0 102 0x04>;
+				gpr = <&gpr>;
+				clocks = <&clks 138>, <&clks 204>;
+				clock-names = "mipi_pllref_clk", "mipi_cfg_clk";
+				status = "disabled";
+			};
+			 */
+
+			i2c4: i2c@021f8000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx1-i2c";
+				reg = <0x021f8000 0x4000>;
+				interrupts = <0 35 0x04>;
+				status = "okay";
+			};
+		};
+	};
+};
+
+/*
+&iomuxc {
+	epdc {
+		pinctrl_epdc_0: epdcgrp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A16__EPDC_DATA00	   0x80000000
+				MX6QDL_PAD_EIM_DA10__EPDC_DATA01   0x80000000
+				MX6QDL_PAD_EIM_DA12__EPDC_DATA02   0x80000000
+				MX6QDL_PAD_EIM_DA11__EPDC_DATA03   0x80000000
+				MX6QDL_PAD_EIM_LBA__EPDC_DATA04	   0x80000000
+				MX6QDL_PAD_EIM_EB2__EPDC_DATA05	   0x80000000
+				MX6QDL_PAD_EIM_CS0__EPDC_DATA06	   0x80000000
+				MX6QDL_PAD_EIM_RW__EPDC_DATA07	   0x80000000
+				MX6QDL_PAD_EIM_A21__EPDC_GDCLK	   0x80000000
+				MX6QDL_PAD_EIM_A22__EPDC_GDSP	   0x80000000
+				MX6QDL_PAD_EIM_A23__EPDC_GDOE	   0x80000000
+				MX6QDL_PAD_EIM_A24__EPDC_GDRL	   0x80000000
+				MX6QDL_PAD_EIM_D31__EPDC_SDCLK_P   0x80000000
+				MX6QDL_PAD_EIM_D27__EPDC_SDOE	   0x80000000
+				MX6QDL_PAD_EIM_DA1__EPDC_SDLE	   0x80000000
+				MX6QDL_PAD_EIM_EB1__EPDC_SDSHR	   0x80000000
+				MX6QDL_PAD_EIM_DA2__EPDC_BDR0	   0x80000000
+				MX6QDL_PAD_EIM_DA4__EPDC_SDCE0	   0x80000000
+				MX6QDL_PAD_EIM_DA5__EPDC_SDCE1	   0x80000000
+				MX6QDL_PAD_EIM_DA6__EPDC_SDCE2	   0x80000000
+			>;
+		};
+	};
+};
+ */
diff --git a/arch/arm/boot/dts/imx6m300-qdl.dtsi b/arch/arm/boot/dts/imx6m300-qdl.dtsi
new file mode 100644
index 0000000..c41fa97
--- /dev/null
+++ b/arch/arm/boot/dts/imx6m300-qdl.dtsi
@@ -0,0 +1,2020 @@
+/*
+ * Copyright 2015, Megger Instruments, Ltd.
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include "skeleton.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	aliases {
+		flexcan0 = &flexcan1;
+		//flexcan1 = &flexcan2;
+		gpio0 = &gpio1;
+		gpio1 = &gpio2;
+		gpio2 = &gpio3;
+		gpio3 = &gpio4;
+		gpio4 = &gpio5;
+		gpio5 = &gpio6;
+		gpio6 = &gpio7;
+		ipu0 = &ipu1;
+		serial0 = &uart1;
+		serial1 = &uart2;
+		serial2 = &uart3;
+		serial3 = &uart4;
+		serial4 = &uart5;
+		usbphy0 = &usbphy1;
+		usbphy1 = &usbphy2;
+	};
+
+	intc: interrupt-controller@00a01000 {
+		compatible = "arm,cortex-a9-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-controller;
+		reg = <0x00a01000 0x1000>,
+		      <0x00a00100 0x100>;
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ckil {
+			compatible = "fsl,imx-ckil", "fixed-clock";
+			clock-frequency = <32768>;
+		};
+
+		ckih1 {
+			compatible = "fsl,imx-ckih1", "fixed-clock";
+			clock-frequency = <0>;
+		};
+
+		osc {
+			compatible = "fsl,imx-osc", "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	pu_dummy: pudummy_reg {
+		compatible = "fsl,imx6-dummy-pureg"; /* only used in ldo-bypass */
+	};
+
+	mxs_viim {
+		compatible = "fsl,mxs_viim";
+		reg = <0x02098000 0x1000>, /* GPT (general purpose timer) base */
+		      <0x021bc000 0x1000>; /* OCOTP (on-chip one tim programmable) base */
+	};
+
+	soc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		interrupt-parent = <&intc>;
+		ranges;
+		/*
+		 *	Cryptographic Acceleration and Assurance Module (CAAM)
+		 */
+		caam_sm: caam-sm@00100000 {
+			compatible = "fsl,imx6q-caam-sm";
+			reg = <0x00100000 0x3fff>;
+		};
+
+		dma_apbh: dma-apbh@00110000 {
+			compatible = "fsl,imx6q-dma-apbh", "fsl,imx28-dma-apbh";
+			reg = <0x00110000 0x2000>;
+			interrupts = <0 13 0x04>, <0 13 0x04>, <0 13 0x04>, <0 13 0x04>;
+			interrupt-names = "gpmi0", "gpmi1", "gpmi2", "gpmi3";
+			#dma-cells = <1>;
+			dma-channels = <4>;
+			clocks = <&clks 106>;
+		};
+
+		irq_sec_vio: caam_secvio {
+			compatible = "fsl,imx6q-caam-secvio";
+			interrupts = <0 20 0x04>;
+			secvio_src = <0x8000001d>;
+		};
+		/*
+		 *	General Purpose Media Interface
+		 *
+		gpmi: gpmi-nand@00112000 {
+			compatible = "fsl,imx6q-gpmi-nand";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x00112000 0x2000>, <0x00114000 0x2000>;
+			reg-names = "gpmi-nand", "bch";
+			interrupts = <0 15 0x04>;
+			interrupt-names = "bch";
+			clocks = <&clks 152>, <&clks 153>, <&clks 151>,
+				 <&clks 150>, <&clks 149>;
+			clock-names = "gpmi_io", "gpmi_apb", "gpmi_bch",
+				      "gpmi_bch_apb", "per1_bch";
+			dmas = <&dma_apbh 0>;
+			dma-names = "rx-tx";
+			status = "disabled";
+		};
+		 */
+		timer@00a00600 {
+			compatible = "arm,cortex-a9-twd-timer";
+			reg = <0x00a00600 0x20>;
+			interrupts = <1 13 0xf01>;
+			clocks = <&clks 15>;
+		};
+
+		L2: l2-cache@00a02000 {
+			compatible = "arm,pl310-cache";
+			reg = <0x00a02000 0x1000>;
+			interrupts = <0 92 0x04>;
+			cache-unified;
+			cache-level = <2>;
+			arm,tag-latency = <4 2 3>;
+			arm,data-latency = <4 2 3>;
+		};
+
+		pcie: pcie@0x01000000 {
+			compatible = "fsl,imx6q-pcie", "snps,dw-pcie";
+			reg = <0x01ffc000 0x4000>; /* DBI */
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			ranges = <0x00000800 0 0x01f00000 0x01f00000 0 0x00080000 /* configuration space */
+				  0x81000000 0 0          0x01f80000 0 0x00010000 /* downstream I/O */
+				  0x82000000 0 0x01000000 0x01000000 0 0x00f00000>; /* non-prefetchable memory */
+			num-lanes = <1>;
+			interrupts = <0 123 0x04>;
+			clocks = <&clks 189>, <&clks 187>, <&clks 144>, <&clks 212>;
+			clock-names = "pcie_ref_125m", "sata_ref_100m", "pcie_axi", "lvds_gate";
+			status = "disabled";
+		};
+		/*
+		 *	Power Management Unit (PMU)
+		 */
+		pmu {
+			compatible = "arm,cortex-a9-pmu";
+			interrupts = <0 94 0x04>;
+		};
+
+		aips-bus@02000000 { /* AIPS1 */
+			compatible = "fsl,aips-bus", "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x02000000 0x100000>;
+			ranges;
+			/*
+			 *	Shared Peripheral Bus Arbiter (SPBA)
+			 */
+			spba-bus@02000000 {
+				compatible = "fsl,spba-bus", "simple-bus";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x02000000 0x40000>;
+				ranges;
+				/*
+				 *	Sony/Philips Digital Interface Format (SPDIF) - Unused on M300
+				 */
+				spdif: spdif@02004000 {
+					compatible = "fsl,imx6q-spdif",
+						"fsl,imx35-spdif";
+					reg = <0x02004000 0x4000>;
+					interrupts = <0 52 0x04>;
+					dmas = <&sdma 14 18 0>,
+					       <&sdma 15 18 0>;
+					dma-names = "rx", "tx";
+					clocks = <&clks 197>, <&clks 3>,
+					       <&clks 197>, <&clks 107>,
+					       <&clks 0>, <&clks 118>,
+					       <&clks 62>, <&clks 139>,
+					       <&clks 0>, <&clks 156>;
+					clock-names = "core", "rxtx0",
+						"rxtx1", "rxtx2",
+						"rxtx3", "rxtx4",
+						"rxtx5", "rxtx6",
+						"rxtx7", "dma";
+					status = "disabled";
+				};
+				/*
+				 * Enhanced Configurable Serial Peripheral Interface (ECSPI)
+				 */
+				ecspi1: ecspi@02008000 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,imx6q-ecspi", "fsl,imx51-ecspi";
+					reg = <0x02008000 0x4000>;
+					interrupts = <0 31 0x04>;
+					clocks = <&clks 112>, <&clks 112>;
+					clock-names = "ipg", "per";
+					status = "okay";
+				};
+				/*
+				 *	ECSPI2, 3 & 4 remain disabled on M300
+				 *
+				ecspi2: ecspi@0200c000 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,imx6q-ecspi", "fsl,imx51-ecspi";
+					reg = <0x0200c000 0x4000>;
+					interrupts = <0 32 0x04>;
+					clocks = <&clks 113>, <&clks 113>;
+					clock-names = "ipg", "per";
+					status = "disabled";
+				};
+
+				ecspi3: ecspi@02010000 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,imx6q-ecspi", "fsl,imx51-ecspi";
+					reg = <0x02010000 0x4000>;
+					interrupts = <0 33 0x04>;
+					clocks = <&clks 114>, <&clks 114>;
+					clock-names = "ipg", "per";
+					status = "disabled";
+				};
+
+				ecspi4: ecspi@02014000 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "fsl,imx6q-ecspi", "fsl,imx51-ecspi";
+					reg = <0x02014000 0x4000>;
+					interrupts = <0 34 0x04>;
+					clocks = <&clks 115>, <&clks 115>;
+					clock-names = "ipg", "per";
+					status = "disabled";
+				};
+				 */
+				/*
+				 * M300 implements 3 UARTs (iMX6 UARTs 1, 4 and 5)
+				 */
+				uart1: serial@02020000 {
+					compatible = "fsl,imx6q-uart", "fsl,imx21-uart";
+					reg = <0x02020000 0x4000>;
+					interrupts = <0 26 0x04>;
+					clocks = <&clks 160>, <&clks 161>;
+					clock-names = "ipg", "per";
+					dmas = <&sdma 25 4 0>, <&sdma 26 4 0>;
+					dma-names = "rx", "tx";
+					status = "okay";
+				};
+				/*
+				 * Enhanced Serial Audio Interface (ESAI). 
+				 * Not implemented on M300
+				 *
+				esai: esai@02024000 {
+					compatible = "fsl,imx6q-esai";
+					reg = <0x02024000 0x4000>;
+					interrupts = <0 51 0x04>;
+					clocks = <&clks 118>, <&clks 156>;
+					clock-names = "core", "dma";
+					fsl,esai-dma-events = <24 23>;
+					fsl,flags = <1>;
+					status = "disabled";
+				};
+				 */
+				 
+				/*
+				 * Synchronous Serial Interface (SSI) aka I2S
+				 */
+				ssi1: ssi@02028000 {
+					compatible = "fsl,imx6q-ssi","fsl,imx21-ssi";
+					reg = <0x02028000 0x4000>;
+					interrupts = <0 46 0x04>;
+					clocks = <&clks 178>, <&clks 157>;
+					clock-names = "ipg", "baud";
+					dmas = <&sdma 37 1 0>,
+					       <&sdma 38 1 0>;
+					dma-names = "rx", "tx";
+					status = "okay";
+				};
+				/*
+				 * SSI2 and 3 remain disabled on M300
+				 */
+				ssi2: ssi@0202c000 {
+					compatible = "fsl,imx6q-ssi","fsl,imx21-ssi";
+					reg = <0x0202c000 0x4000>;
+					interrupts = <0 47 0x04>;
+					clocks = <&clks 179>, <&clks 158>;
+					clock-names = "ipg", "baud";
+					dmas = <&sdma 41 1 0>,
+					       <&sdma 42 1 0>;
+					dma-names = "rx", "tx";
+					status = "disabled";
+				};
+
+				ssi3: ssi@02030000 {
+					compatible = "fsl,imx6q-ssi","fsl,imx21-ssi";
+					reg = <0x02030000 0x4000>;
+					interrupts = <0 48 0x04>;
+					clocks = <&clks 180>, <&clks 159>;
+					clock-names = "ipg", "baud";
+					dmas = <&sdma 45 1 0>,
+					       <&sdma 46 1 0>;
+					dma-names = "rx", "tx";
+					status = "disabled";
+				};
+				/*
+				 * Asynchronous Sample Rate Converter (ASRC)
+				 */
+				asrc: asrc@02034000 {
+					compatible = "fsl,imx53-asrc";
+					reg = <0x02034000 0x4000>;
+					interrupts = <0 50 0x04>;
+					clocks = <&clks 107>, <&clks 156>;
+					clock-names = "core", "dma";
+					dmas = <&sdma 17 20 1>, <&sdma 18 20 1>, <&sdma 19 20 1>,
+					     <&sdma 20 20 1>, <&sdma 21 20 1>, <&sdma 22 20 1>;
+					dma-names = "rxa", "rxb", "rxc",
+						"txa", "txb", "txc";
+					status = "okay";
+				};
+
+				asrc_p2p: asrc_p2p {
+					compatible = "fsl,imx6q-asrc-p2p";
+					fsl,output-rate  = <48000>;
+					fsl,output-width = <16>;
+					fsl,asrc-dma-rx-events = <17 18 19>;
+					fsl,asrc-dma-tx-events = <20 21 22>;
+					status = "okay";
+				};
+				/*
+				 * Shared Peripheral Bus Arbiter
+				 */
+				spba@0203c000 {
+					reg = <0x0203c000 0x4000>;
+				};
+			};
+
+			vpu: vpu@02040000 {
+				compatible = "fsl,imx6-vpu";
+				reg = <0x02040000 0x3c000>;
+				reg-names = "vpu_regs";
+				interrupts = <0 3 0x01>, <0 12 0x04>;
+				interrupt-names = "vpu_jpu_irq", "vpu_ipi_irq";
+				clocks = <&clks 168>, <&clks 140>, <&clks 142>;
+				clock-names = "vpu_clk", "mmdc_ch0_axi", "ocram";
+				iramsize = <0x21000>;
+				iram = <&ocram>;
+				resets = <&src 1>;
+				pu-supply = <&reg_pu>;
+				status = "disabled";
+			};
+
+			aipstz@0207c000 { /* AIPSTZ1 */
+				reg = <0x0207c000 0x4000>;
+			};
+			/*
+			 * PWM1 is used for LVDS brightness control on M300
+			 * (could also control parallel LCD brightness, but 
+			 * hard wired on M300 Carrier)
+			 */
+			pwm1: pwm@02080000 {
+				#pwm-cells = <2>;
+				compatible = "fsl,imx6q-pwm", "fsl,imx27-pwm";
+				reg = <0x02080000 0x4000>;
+				interrupts = <0 83 0x04>;
+				clocks = <&clks 62>, <&clks 145>;
+				clock-names = "ipg", "per";
+			};
+			/*
+			 * PWM2 Can be used for a buzzer on M300 - it is available 
+			 * on GPIO01_IO19 (SD1_DATA2)
+			 */
+			pwm2: pwm@02084000 {
+				#pwm-cells = <2>;
+				compatible = "fsl,imx6q-pwm", "fsl,imx27-pwm";
+				reg = <0x02084000 0x4000>;
+				interrupts = <0 84 0x04>;
+				clocks = <&clks 62>, <&clks 146>;
+				clock-names = "ipg", "per";
+			};
+
+			/*
+			 * PWM3 is not available on M300
+			 *
+			pwm3: pwm@02088000 {
+				#pwm-cells = <2>;
+				compatible = "fsl,imx6q-pwm", "fsl,imx27-pwm";
+				reg = <0x02088000 0x4000>;
+				interrupts = <0 85 0x04>;
+				clocks = <&clks 62>, <&clks 147>;
+				clock-names = "ipg", "per";
+				status = "disabled";
+			};
+			 */
+
+			/*
+			 * PWM4 is not available on M300
+			 *
+			pwm4: pwm@0208c000 {
+				#pwm-cells = <2>;
+				compatible = "fsl,imx6q-pwm", "fsl,imx27-pwm";
+				reg = <0x0208c000 0x4000>;
+				interrupts = <0 86 0x04>;
+				clocks = <&clks 62>, <&clks 148>;
+				clock-names = "ipg", "per";
+				status = "disabled";
+			};
+			 */
+			/*
+			 * Flexible Controller Area Network (FlexCAN) - Freescale's implementation of CAN
+			 */
+			flexcan1: can@02090000 {
+				compatible = "fsl,imx6q-flexcan";
+				reg = <0x02090000 0x4000>;
+				interrupts = <0 110 0x04>;
+				clocks = <&clks 108>, <&clks 109>;
+				clock-names = "ipg", "per";
+				gpr = <&gpr>;
+				status = "okay";
+			};
+			/*
+			 * FlexCAN2 remains disabled on M300
+			 *
+			flexcan2: can@02094000 {
+				compatible = "fsl,imx6q-flexcan";
+				reg = <0x02094000 0x4000>;
+				interrupts = <0 111 0x04>;
+				clocks = <&clks 110>, <&clks 111>;
+				clock-names = "ipg", "per";
+				gpr = <&gpr>;
+				status = "disabled";
+			};
+			 */
+			/*
+			 * General Purpose Timer (GPT)
+			 */
+			gpt: gpt@02098000 {
+				compatible = "fsl,imx6q-gpt";
+				reg = <0x02098000 0x4000>;
+				interrupts = <0 55 0x04>;
+				clocks = <&clks 119>, <&clks 120>;
+				clock-names = "ipg", "per";
+			};
+
+			gpio1: gpio@0209c000 {
+				compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";
+				reg = <0x0209c000 0x4000>;
+				interrupts = <0 66 0x04 0 67 0x04>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio2: gpio@020a0000 {
+				compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";
+				reg = <0x020a0000 0x4000>;
+				interrupts = <0 68 0x04 0 69 0x04>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio3: gpio@020a4000 {
+				compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";
+				reg = <0x020a4000 0x4000>;
+				interrupts = <0 70 0x04 0 71 0x04>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio4: gpio@020a8000 {
+				compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";
+				reg = <0x020a8000 0x4000>;
+				interrupts = <0 72 0x04 0 73 0x04>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio5: gpio@020ac000 {
+				compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";
+				reg = <0x020ac000 0x4000>;
+				interrupts = <0 74 0x04 0 75 0x04>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio6: gpio@020b0000 {
+				compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";
+				reg = <0x020b0000 0x4000>;
+				interrupts = <0 76 0x04 0 77 0x04>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio7: gpio@020b4000 {
+				compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";
+				reg = <0x020b4000 0x4000>;
+				interrupts = <0 78 0x04 0 79 0x04>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+			/*
+			 * KeyPad Port (KPP)
+			 */
+			kpp: kpp@020b8000 {
+				reg = <0x020b8000 0x4000>;
+				interrupts = <0 82 0x04>;
+			};
+
+			wdog1: wdog@020bc000 {
+				compatible = "fsl,imx6q-wdt", "fsl,imx21-wdt";
+				reg = <0x020bc000 0x4000>;
+				interrupts = <0 80 0x04>;
+				clocks = <&clks 0>;
+			};
+
+			wdog2: wdog@020c0000 {
+				compatible = "fsl,imx6q-wdt", "fsl,imx21-wdt";
+				reg = <0x020c0000 0x4000>;
+				interrupts = <0 81 0x04>;
+				clocks = <&clks 0>;
+				status = "disabled";
+			};
+
+			clks: ccm@020c4000 {
+				compatible = "fsl,imx6q-ccm";
+				reg = <0x020c4000 0x4000>;
+				interrupts = <0 87 0x04 0 88 0x04>;
+				#clock-cells = <1>;
+			};
+			/*
+			 * Anatop is an internal voltage regulator in the iMX6
+			 */
+			anatop: anatop@020c8000 {
+				compatible = "fsl,imx6q-anatop", "syscon", "simple-bus";
+				reg = <0x020c8000 0x1000>;
+				interrupts = <0 49 0x04 0 54 0x04 0 127 0x04>;
+
+				regulator-1p1@110 {
+					compatible = "fsl,anatop-regulator";
+					regulator-name = "vdd1p1";
+					regulator-min-microvolt = <800000>;
+					regulator-max-microvolt = <1375000>;
+					regulator-always-on;
+					anatop-reg-offset = <0x110>;
+					anatop-vol-bit-shift = <8>;
+					anatop-vol-bit-width = <5>;
+					anatop-min-bit-val = <4>;
+					anatop-min-voltage = <800000>;
+					anatop-max-voltage = <1375000>;
+				};
+
+				regulator-3p0@120 {
+					compatible = "fsl,anatop-regulator";
+					regulator-name = "vdd3p0";
+					regulator-min-microvolt = <2800000>;
+					regulator-max-microvolt = <3150000>;
+					regulator-always-on;
+					anatop-reg-offset = <0x120>;
+					anatop-vol-bit-shift = <8>;
+					anatop-vol-bit-width = <5>;
+					anatop-min-bit-val = <0>;
+					anatop-min-voltage = <2625000>;
+					anatop-max-voltage = <3400000>;
+				};
+
+				regulator-2p5@130 {
+					compatible = "fsl,anatop-regulator";
+					regulator-name = "vdd2p5";
+					regulator-min-microvolt = <2000000>;
+					regulator-max-microvolt = <2750000>;
+					regulator-always-on;
+					anatop-reg-offset = <0x130>;
+					anatop-vol-bit-shift = <8>;
+					anatop-vol-bit-width = <5>;
+					anatop-min-bit-val = <0>;
+					anatop-min-voltage = <2000000>;
+					anatop-max-voltage = <2750000>;
+				};
+
+				reg_arm: regulator-vddcore@140 {
+					compatible = "fsl,anatop-regulator";
+					regulator-name = "cpu";
+					regulator-min-microvolt = <725000>;
+					regulator-max-microvolt = <1450000>;
+					regulator-always-on;
+					anatop-reg-offset = <0x140>;
+					anatop-vol-bit-shift = <0>;
+					anatop-vol-bit-width = <5>;
+					anatop-delay-reg-offset = <0x170>;
+					anatop-delay-bit-shift = <24>;
+					anatop-delay-bit-width = <2>;
+					anatop-min-bit-val = <1>;
+					anatop-min-voltage = <725000>;
+					anatop-max-voltage = <1450000>;
+				};
+
+				reg_pu: regulator-vddpu@140 {
+					compatible = "fsl,anatop-regulator";
+					regulator-name = "vddpu";
+					regulator-min-microvolt = <725000>;
+					regulator-max-microvolt = <1450000>;
+					anatop-reg-offset = <0x140>;
+					anatop-vol-bit-shift = <9>;
+					anatop-vol-bit-width = <5>;
+					anatop-delay-reg-offset = <0x170>;
+					anatop-delay-bit-shift = <26>;
+					anatop-delay-bit-width = <2>;
+					anatop-min-bit-val = <1>;
+					anatop-min-voltage = <725000>;
+					anatop-max-voltage = <1450000>;
+				};
+
+				reg_soc: regulator-vddsoc@140 {
+					compatible = "fsl,anatop-regulator";
+					regulator-name = "vddsoc";
+					regulator-min-microvolt = <725000>;
+					regulator-max-microvolt = <1450000>;
+					regulator-always-on;
+					anatop-reg-offset = <0x140>;
+					anatop-vol-bit-shift = <18>;
+					anatop-vol-bit-width = <5>;
+					anatop-delay-reg-offset = <0x170>;
+					anatop-delay-bit-shift = <28>;
+					anatop-delay-bit-width = <2>;
+					anatop-min-bit-val = <1>;
+					anatop-min-voltage = <725000>;
+					anatop-max-voltage = <1450000>;
+				};
+			};
+			/*
+			 * Temperature Monitor (TempMon)
+			 */
+			tempmon: tempmon {
+				compatible = "fsl,imx6q-tempmon";
+				interrupts = <0 49 0x04>;
+				fsl,tempmon = <&anatop>;
+				fsl,tempmon-data = <&ocotp>;
+				clocks = <&clks 172>;
+			};
+
+			usbphy1: usbphy@020c9000 {
+				compatible = "fsl,imx6q-usbphy", "fsl,imx23-usbphy";
+				reg = <0x020c9000 0x1000>;
+				interrupts = <0 44 0x04>;
+				clocks = <&clks 182>;
+				fsl,anatop = <&anatop>;
+			};
+
+			usbphy2: usbphy@020ca000 {
+				compatible = "fsl,imx6q-usbphy", "fsl,imx23-usbphy";
+				reg = <0x020ca000 0x1000>;
+				interrupts = <0 45 0x04>;
+				clocks = <&clks 183>;
+				fsl,anatop = <&anatop>;
+			};
+
+			usbphy_nop1: usbphy_nop1 {
+				compatible = "usb-nop-xceiv";
+				clocks = <&clks 182>;
+				clock-names = "main_clk";
+			};
+
+			usbphy_nop2: usbphy_nop2 {
+				compatible = "usb-nop-xceiv";
+				clocks = <&clks 182>;
+				clock-names = "main_clk";
+			};
+
+			caam_snvs: caam-snvs@020cc000 {
+				compatible = "fsl,imx6q-caam-snvs";
+				reg = <0x020cc000 0x4000>;
+			};
+			/*
+			 * Secure Non-Volatile Storage (Real time clock based battery backed RAM)
+			 * (SNVS)
+			 */
+			snvs@020cc000 {
+				compatible = "fsl,sec-v4.0-mon", "simple-bus";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x020cc000 0x4000>;
+
+				snvs-rtc-lp@34 {
+					compatible = "fsl,sec-v4.0-mon-rtc-lp";
+					reg = <0x34 0x58>;
+					interrupts = <0 19 0x04 0 20 0x04>;
+				};
+			};
+			/*
+			 * Enhanced Periodic Interrupt Controller (EPIT)
+			 */
+			epit1: epit@020d0000 { /* EPIT1 */
+				reg = <0x020d0000 0x4000>;
+				interrupts = <0 56 0x04>;
+			};
+
+			epit2: epit@020d4000 { /* EPIT2 */
+				reg = <0x020d4000 0x4000>;
+				interrupts = <0 57 0x04>;
+			};
+
+			src: src@020d8000 {
+				compatible = "fsl,imx6q-src", "fsl,imx51-src";
+				reg = <0x020d8000 0x4000>;
+				interrupts = <0 91 0x04 0 96 0x04>;
+				#reset-cells = <1>;
+			};
+
+			gpc: gpc@020dc000 {
+				compatible = "fsl,imx6q-gpc";
+				reg = <0x020dc000 0x4000>;
+				interrupts = <0 89 0x04 0 90 0x04>;
+				clocks = <&clks 122>, <&clks 74>, <&clks 121>,
+					<&clks 26>, <&clks 143>, <&clks 168>, <&clks 62>;
+				clock-names = "gpu3d_core", "gpu3d_shader", "gpu2d_core",
+					"gpu2d_axi", "openvg_axi", "vpu_axi", "ipg";
+				pu-supply = <&reg_pu>;
+			};
+
+			gpr: iomuxc-gpr@020e0000 {
+				compatible = "fsl,imx6q-iomuxc-gpr", "syscon";
+				reg = <0x020e0000 0x38>;
+			};
+
+			iomuxc: iomuxc@020e0000 {
+				reg = <0x020e0000 0x4000>;
+			};
+			/*
+			 * LVDS Display Bridge (LDB)
+			 */
+			ldb: ldb@020e0008 {
+				compatible = "fsl,imx6q-ldb", "fsl,imx53-ldb";
+				reg = <0x020e0000 0x4000>;
+				clocks = <&clks 135>, <&clks 136>,
+					 <&clks 39>, <&clks 40>,
+					 <&clks 41>, <&clks 42>,
+					 <&clks 184>, <&clks 185>,
+					 <&clks 205>, <&clks 206>,
+					 <&clks 207>, <&clks 208>;
+				clock-names = "ldb_di0", "ldb_di1",
+					      "ipu1_di0_sel", "ipu1_di1_sel",
+					      "ipu2_di0_sel", "ipu2_di1_sel",
+					      "di0_div_3_5", "di1_div_3_5",
+					      "di0_div_7", "di1_div_7",
+					      "di0_div_sel", "di1_div_sel";
+				status = "disabled";
+			};
+			/*
+			 * Display Content Integrity Checker (DCIC)
+			 */
+			dcic1: dcic@020e4000 {
+				reg = <0x020e4000 0x4000>;
+				interrupts = <0 124 0x04>;
+			};
+
+			dcic2: dcic@020e8000 {
+				reg = <0x020e8000 0x4000>;
+				interrupts = <0 125 0x04>;
+			};
+
+			sdma: sdma@020ec000 {
+				compatible = "fsl,imx6q-sdma", "fsl,imx35-sdma";
+				reg = <0x020ec000 0x4000>;
+				interrupts = <0 2 0x04>;
+				clocks = <&clks 155>, <&clks 155>;
+				clock-names = "ipg", "ahb";
+				#dma-cells = <3>;
+				fsl,sdma-ram-script-name = "imx/sdma/sdma-imx6q.bin";
+			};
+		};
+
+		aips-bus@02100000 { /* AIPS2 */
+			compatible = "fsl,aips-bus", "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x02100000 0x100000>;
+			ranges;
+
+			crypto: caam@2100000 {
+				compatible = "fsl,sec-v4.0";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x2100000 0x40000>;
+				ranges = <0 0x2100000 0x40000>;
+				interrupt-parent = <&intc>; /* interrupts = <0 92 0x4>; */
+				clocks = <&clks 213>, <&clks 214>, <&clks 215> ,<&clks 196>;
+				clock-names = "caam_mem", "caam_aclk", "caam_ipg", "caam_emi_slow";
+
+				sec_jr0: jr0@1000 {
+					compatible = "fsl,sec-v4.0-job-ring";
+					reg = <0x1000 0x1000>;
+					interrupt-parent = <&intc>;
+					interrupts = <0 105 0x4>;
+				};
+
+				sec_jr1: jr1@2000 {
+					compatible = "fsl,sec-v4.0-job-ring";
+					reg = <0x2000 0x1000>;
+					interrupt-parent = <&intc>;
+					interrupts = <0 106 0x4>;
+				};
+			};
+
+			aipstz@0217c000 { /* AIPSTZ2 */
+				reg = <0x0217c000 0x4000>;
+			};
+			/*
+			 * USB-OTG is available as a USB2.0 host or device on the M300
+			 */
+			usbotg: usb@02184000 {
+				compatible = "fsl,imx6q-usb", "fsl,imx27-usb";
+				reg = <0x02184000 0x200>;
+				interrupts = <0 43 0x04>;
+				clocks = <&clks 162>;
+				fsl,usbphy = <&usbphy1>;
+				fsl,usbmisc = <&usbmisc 0>;
+				fsl,anatop = <&anatop>;
+				status = "okay";
+			};
+			/*
+			 * USB H1 is available as a USB2.0 host on the M300
+			 */
+			usbh1: usb@02184200 {
+				compatible = "fsl,imx6q-usb", "fsl,imx27-usb";
+				reg = <0x02184200 0x200>;
+				interrupts = <0 40 0x04>;
+				clocks = <&clks 162>;
+				fsl,usbphy = <&usbphy2>;
+				fsl,usbmisc = <&usbmisc 1>;
+				status = "okay";
+			};
+			/*
+			 * USB2 is not available on the M300
+			 *
+			usbh2: usb@02184400 {
+				compatible = "fsl,imx6q-usb", "fsl,imx27-usb";
+				reg = <0x02184400 0x200>;
+				interrupts = <0 41 0x04>;
+				clocks = <&clks 162>;
+				fsl,usbmisc = <&usbmisc 2>;
+				phy_type = "hsic";
+				fsl,usbphy = <&usbphy_nop1>;
+				fsl,anatop = <&anatop>;
+				status = "disabled";
+			};
+			 */
+			/*
+			 * USB3 is not available on the M300
+			 *
+			usbh3: usb@02184600 {
+				compatible = "fsl,imx6q-usb", "fsl,imx27-usb";
+				reg = <0x02184600 0x200>;
+				interrupts = <0 42 0x04>;
+				clocks = <&clks 162>;
+				fsl,usbmisc = <&usbmisc 3>;
+				phy_type = "hsic";
+				fsl,usbphy = <&usbphy_nop2>;
+				fsl,anatop = <&anatop>;
+				status = "disabled";
+			};
+			 */
+
+			usbmisc: usbmisc: usbmisc@02184800 {
+				#index-cells = <1>;
+				compatible = "fsl,imx6q-usbmisc";
+				reg = <0x02184800 0x200>;
+				clocks = <&clks 162>;
+			};
+			/*
+			 * Fast Ethernet Controller (FEC)
+			 */
+			fec: ethernet@02188000 {
+				compatible = "fsl,imx6q-fec";
+				reg = <0x02188000 0x4000>;
+				interrupts = <0 118 0x04 0 119 0x04>;
+				clocks = <&clks 117>, <&clks 117>, <&clks 190>;
+				clock-names = "ipg", "ahb", "ptp";
+				status = "disabled";
+			};
+			/*
+			 * Media Local Bus
+			 */
+			mlb: mlb@0218c000 {
+				compatible = "fsl,imx6q-mlb150";
+				reg = <0x0218c000 0x4000>;
+				interrupts = <0 53 0x04 0 117 0x04 0 126 0x04>;
+				clocks = <&clks 139>, <&clks 175>;
+				clock-names = "mlb", "pll8_mlb";
+				iram = <&ocram>;
+				status = "disabled";
+			};
+			/*
+			 * Ultra Secured Digital Host Controller (USDHC) - Freescale's
+			 * SD implementation.
+			 *
+			 * M300 boots from SD2 (4-bit mode) and has full 8-bit mode access
+			 * to off-module SD4
+			 *
+			 * USDHC1 is not available on the M300
+			 *
+			usdhc1: usdhc@02190000 {
+				compatible = "fsl,imx6q-usdhc";
+				reg = <0x02190000 0x4000>;
+				interrupts = <0 22 0x04>;
+				clocks = <&clks 163>, <&clks 163>, <&clks 163>;
+				clock-names = "ipg", "ahb", "per";
+				bus-width = <4>;
+				status = "disabled";
+			};
+			 */
+			/*
+			 * USDHC2 - boot device for M300
+			 */
+			usdhc2: usdhc@02194000 {
+				compatible = "fsl,imx6q-usdhc";
+				reg = <0x02194000 0x4000>;
+				interrupts = <0 23 0x04>;
+				clocks = <&clks 164>, <&clks 164>, <&clks 164>;
+				clock-names = "ipg", "ahb", "per";
+				bus-width = <4>;
+				status = "disabled";
+			};
+			/*
+			 * USDHC3 is not available on the M300
+			 *
+			usdhc3: usdhc@02198000 {
+				compatible = "fsl,imx6q-usdhc";
+				reg = <0x02198000 0x4000>;
+				interrupts = <0 24 0x04>;
+				clocks = <&clks 165>, <&clks 165>, <&clks 165>;
+				clock-names = "ipg", "ahb", "per";
+				bus-width = <4>;
+				status = "disabled";
+			};
+			 */
+			/*
+			 * USDHC4 is off-module non-volatile storage for M300
+			 */
+			usdhc4: usdhc@0219c000 {
+				compatible = "fsl,imx6q-usdhc";
+				reg = <0x0219c000 0x4000>;
+				interrupts = <0 25 0x04>;
+				clocks = <&clks 166>, <&clks 166>, <&clks 166>;
+				clock-names = "ipg", "ahb", "per";
+				bus-width = <8>;
+				status = "disabled";
+			};
+			/*
+			 * I2C1 is used as the control channel for the SGT5000 Audio Codec
+			 */
+			i2c1: i2c@021a0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx6q-i2c", "fsl,imx21-i2c";
+				reg = <0x021a0000 0x4000>;
+				interrupts = <0 36 0x04>;
+				clocks = <&clks 125>;
+				status = "disabled";
+			};
+			/*
+			 * I2C2 is not available on the M300
+			 */
+			i2c2: i2c@021a4000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx6q-i2c", "fsl,imx21-i2c";
+				reg = <0x021a4000 0x4000>;
+				interrupts = <0 37 0x04>;
+				clocks = <&clks 126>;
+				status = "disabled";
+			};
+			/*
+			 * I2C3 is available; on the carrier board it goes to both a header
+			 * and to a serial EEPROM (Atmel AT24C02D 2kB - as 256x8 bits)
+			 */
+			i2c3: i2c@021a8000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx6q-i2c", "fsl,imx21-i2c";
+				reg = <0x021a8000 0x4000>;
+				interrupts = <0 38 0x04>;
+				clocks = <&clks 127>;
+				status = "disabled";
+			};
+
+			romcp@021ac000 {
+				reg = <0x021ac000 0x4000>;
+			};
+			/*
+			 * Multi Mode DDR Controller (MMDC)
+			 */
+			mmdc0-1@021b0000 { /* MMDC0-1 */
+				compatible = "fsl,imx6q-mmdc-combine";
+				reg = <0x021b0000 0x8000>;
+			};
+
+			mmdc0: mmdc@021b0000 { /* MMDC0 */
+				compatible = "fsl,imx6q-mmdc";
+				reg = <0x021b0000 0x4000>;
+			};
+
+			mmdc1: mmdc@021b4000 { /* MMDC1 */
+				reg = <0x021b4000 0x4000>;
+			};
+			/*
+			 * External Interface Module (EIM or WEIM) - control for
+			 * external memory such as NOR FLASH (Synchronous) or SRAM
+			 * type devices (Asynchronous) - the M300 has neither.
+			 *
+			weim: weim@021b8000 {
+				compatible = "fsl,imx6q-weim";
+				reg = <0x021b8000 0x4000>;
+				interrupts = <0 14 0x04>;
+				clocks = <&clks 196>;
+			};
+			 */
+			/*
+			 * On Chip One-Time Programmable controller (OCOTP) (i.e. fuses)
+			 */
+			ocotp: ocotp-ctrl@021bc000 {
+				compatible = "syscon";
+				reg = <0x021bc000 0x4000>;
+			};
+
+			ocotp-fuse@021bc000 {
+				compatible = "fsl,imx6q-ocotp";
+				reg = <0x021bc000 0x4000>;
+				clocks = <&clks 128>;
+			};
+			/*
+			 * Trust Zone Address Space Controller (TZASC)
+			 */
+			tzasc@021d0000 { /* TZASC1 */
+				reg = <0x021d0000 0x4000>;
+				interrupts = <0 108 0x04>;
+			};
+
+			tzasc@021d4000 { /* TZASC2 */
+				reg = <0x021d4000 0x4000>;
+				interrupts = <0 109 0x04>;
+			};
+
+			audmux: audmux@021d8000 {
+				compatible = "fsl,imx6q-audmux", "fsl,imx31-audmux";
+				reg = <0x021d8000 0x4000>;
+				status = "disabled";
+			};
+			/*
+			 * MIPI Camera Sensor Interface (MIPI-CSI)
+			 *
+			 * One MIPI-CSI port i available on M300
+			 */
+			mipi_csi: mipi_csi@021dc000 {
+				compatible = "fsl,imx6q-mipi-csi2";
+				reg = <0x021dc000 0x4000>;
+				interrupts = <0 100 0x04>, <0 101 0x04>;
+				clocks = <&clks 138>, <&clks 53>, <&clks 204>;
+				/* Note: clks 138 is hsi_tx, however, the dphy_c
+				 * hsi_tx and pll_refclk use the same clk gate.
+				 * In current clk driver, open/close clk gate do
+				 * use hsi_tx for a temporary debug purpose.
+				 */
+				clock-names = "dphy_clk", "pixel_clk", "cfg_clk";
+				status = "disabled";
+			};
+			/*
+			 * Video Data Order Adapter (VDOA)
+			 */
+			vdoa@021e4000 {
+				compatible = "fsl,imx6q-vdoa";
+				reg = <0x021e4000 0x4000>;
+				interrupts = <0 18 0x04>;
+				clocks = <&clks 202>;
+				iram = <&ocram>;
+			};
+			/*
+			 * UART2 is not available on the M300
+			 */
+			uart2: serial@021e8000 {
+				compatible = "fsl,imx6q-uart", "fsl,imx21-uart";
+				reg = <0x021e8000 0x4000>;
+				interrupts = <0 27 0x04>;
+				clocks = <&clks 160>, <&clks 161>;
+				clock-names = "ipg", "per";
+				dmas = <&sdma 27 4 0>, <&sdma 28 4 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+			/*
+			 * UART3 is not available on the M300
+			 */
+			uart3: serial@021ec000 {
+				compatible = "fsl,imx6q-uart", "fsl,imx21-uart";
+				reg = <0x021ec000 0x4000>;
+				interrupts = <0 28 0x04>;
+				clocks = <&clks 160>, <&clks 161>;
+				clock-names = "ipg", "per";
+				dmas = <&sdma 29 4 0>, <&sdma 30 4 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+			/*
+			 * UART4 is available as serial port 1 on the M300
+			 */
+			uart4: serial@021f0000 {
+				compatible = "fsl,imx6q-uart", "fsl,imx21-uart";
+				reg = <0x021f0000 0x4000>;
+				interrupts = <0 29 0x04>;
+				clocks = <&clks 160>, <&clks 161>;
+				clock-names = "ipg", "per";
+				dmas = <&sdma 31 4 0>, <&sdma 32 4 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+			/*
+			 * UART5 is available as serial port 2 on the M300
+			 */
+			uart5: serial@021f4000 {
+				compatible = "fsl,imx6q-uart", "fsl,imx21-uart";
+				reg = <0x021f4000 0x4000>;
+				interrupts = <0 30 0x04>;
+				clocks = <&clks 160>, <&clks 161>;
+				clock-names = "ipg", "per";
+				dmas = <&sdma 33 4 0>, <&sdma 34 4 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+		};
+		/*
+		 * Image Processing Unit (IPU)
+		 */
+		ipu1: ipu@02400000 {
+			compatible = "fsl,imx6q-ipu";
+			reg = <0x02400000 0x400000>;
+			interrupts = <0 6 0x4 0 5 0x4>;
+			clocks = <&clks 130>, <&clks 131>, <&clks 132>,
+				 <&clks 39>, <&clks 40>,
+				 <&clks 135>, <&clks 136>;
+			clock-names = "bus", "di0", "di1",
+				      "di0_sel", "di1_sel",
+				      "ldb_di0", "ldb_di1";
+			resets = <&src 2>;
+			bypass_reset = <0>;
+		};
+	};
+};
+
+
+&iomuxc {
+	audmux {
+		/*
+		 * The audio mux also uses AUD.CLK (pin P6)
+		 */
+		pinctrl_audmux_1: audmux-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__AUD3_RXC  0x130b0
+				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC   0x130b0
+				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD   0x110b0
+				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS  0x130b0
+				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD	 0x130b0
+				MX6QDL_PAD_CSI0_DAT11__AUD3_RXFS 0x130b0
+				MX6QDL_PAD_GPIO_18__ASRC_EXT_CLK 0x130b0
+			>;
+		};
+	};
+
+	ecspi1 {
+	    /*
+		pinctrl_ecspi1_cs_1: ecspi1_cs_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D19__GPIO3_IO19 0x80000000
+			>;
+		};
+		 */
+
+		pinctrl_ecspi1_1: ecspi1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK 0x100b1
+				MX6QDL_PAD_GPIO_19__ECSPI1_RDY  0x100b1
+				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI 0x100b1
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO 0x100b1
+				MX6QDL_PAD_EIM_D19__ECSPI1_SS1  0x100b1
+				MX6QDL_PAD_EIM_D24__ECSPI1_SS2  0x100b1
+			>;
+		};
+		
+		/*
+		pinctrl_ecspi1_2: ecspi1grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL1__ECSPI1_MISO 0x100b1
+				MX6QDL_PAD_KEY_ROW0__ECSPI1_MOSI 0x100b1
+				MX6QDL_PAD_KEY_COL0__ECSPI1_SCLK 0x100b1
+			>;
+		};
+		 */
+	};
+
+	/*
+	 * ESCPI 3 no used on M300
+	 *
+	ecspi3 {
+		pinctrl_ecspi3_1: ecspi3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_DISP0_DAT2__ECSPI3_MISO 0x100b1
+				MX6QDL_PAD_DISP0_DAT1__ECSPI3_MOSI 0x100b1
+				MX6QDL_PAD_DISP0_DAT0__ECSPI3_SCLK 0x100b1
+			>;
+		};
+	};
+	 */
+
+	enet {
+		pinctrl_enet_1: enetgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0   0x1b0b0
+				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1   0x1b0b0
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN     0x1b0b0
+				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0   0x1b0b0
+				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1   0x1b0b0
+				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN    0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO	      0x1b0b0
+				MX6QDL_PAD_ENET_RX_ER__ENET_RX_ER     0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK      0x4001b0a8
+			>;
+		};
+		/*
+		pinctrl_enet_1: enetgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK      0x4001b0a8
+			>;
+		};
+		*/
+		
+		/*
+		 * ENET 2 and 3 are not implemented on M300
+		 *
+		pinctrl_enet_2: enetgrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL1__ENET_MDIO        0x1b0b0
+				MX6QDL_PAD_KEY_COL2__ENET_MDC         0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK      0x4001b0a8
+			>;
+		};
+
+		pinctrl_enet_3: enetgrp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN     0x1b0b0
+			>;
+		};
+		 */
+	};
+
+	/*
+	esai {
+		pinctrl_esai_1: esaigrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RXD0__ESAI_TX_HF_CLK 0x1b030
+				MX6QDL_PAD_ENET_CRS_DV__ESAI_TX_CLK  0x1b030
+				MX6QDL_PAD_ENET_RXD1__ESAI_TX_FS     0x1b030
+				MX6QDL_PAD_ENET_TX_EN__ESAI_TX3_RX2  0x1b030
+				MX6QDL_PAD_ENET_TXD1__ESAI_TX2_RX3   0x1b030
+				MX6QDL_PAD_ENET_TXD0__ESAI_TX4_RX1   0x1b030
+				MX6QDL_PAD_ENET_MDC__ESAI_TX5_RX0    0x1b030
+				MX6QDL_PAD_NANDF_CS2__ESAI_TX0       0x1b030
+				MX6QDL_PAD_NANDF_CS3__ESAI_TX1       0x1b030
+			>;
+		};
+
+		pinctrl_esai_2: esaigrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_CRS_DV__ESAI_TX_CLK 0x1b030
+				MX6QDL_PAD_ENET_RXD1__ESAI_TX_FS    0x1b030
+				MX6QDL_PAD_ENET_TX_EN__ESAI_TX3_RX2 0x1b030
+				MX6QDL_PAD_GPIO_5__ESAI_TX2_RX3     0x1b030
+				MX6QDL_PAD_ENET_TXD0__ESAI_TX4_RX1  0x1b030
+				MX6QDL_PAD_ENET_MDC__ESAI_TX5_RX0   0x1b030
+				MX6QDL_PAD_GPIO_17__ESAI_TX0        0x1b030
+				MX6QDL_PAD_NANDF_CS3__ESAI_TX1      0x1b030
+				MX6QDL_PAD_ENET_MDIO__ESAI_RX_CLK   0x1b030
+				MX6QDL_PAD_GPIO_9__ESAI_RX_FS       0x1b030
+			>;
+		};
+	};
+	 */
+
+	flexcan1 {
+		pinctrl_flexcan1_1: flexcan1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_7__FLEXCAN1_TX  0x80000000
+				MX6QDL_PAD_GPIO_8__FLEXCAN1_RX  0x80000000
+			>;
+		};
+	};
+	
+	/*
+	 * FLAXCAN 2 is not used in M300
+	 *
+	flexcan2 {
+		pinctrl_flexcan2_1: flexcan2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX 0x80000000
+				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX 0x80000000
+			>;
+		};
+	};
+	 */
+	
+	/*
+	gpmi-nand {
+		pinctrl_gpmi_nand_1: gpmi-nand-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__NAND_CLE     0xb0b1
+				MX6QDL_PAD_NANDF_ALE__NAND_ALE     0xb0b1
+				MX6QDL_PAD_NANDF_WP_B__NAND_WP_B   0xb0b1
+				MX6QDL_PAD_NANDF_RB0__NAND_READY_B 0xb000
+				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B   0xb0b1
+				MX6QDL_PAD_NANDF_CS1__NAND_CE1_B   0xb0b1
+				MX6QDL_PAD_SD4_CMD__NAND_RE_B      0xb0b1
+				MX6QDL_PAD_SD4_CLK__NAND_WE_B      0xb0b1
+				MX6QDL_PAD_NANDF_D0__NAND_DATA00   0xb0b1
+				MX6QDL_PAD_NANDF_D1__NAND_DATA01   0xb0b1
+				MX6QDL_PAD_NANDF_D2__NAND_DATA02   0xb0b1
+				MX6QDL_PAD_NANDF_D3__NAND_DATA03   0xb0b1
+				MX6QDL_PAD_NANDF_D4__NAND_DATA04   0xb0b1
+				MX6QDL_PAD_NANDF_D5__NAND_DATA05   0xb0b1
+				MX6QDL_PAD_NANDF_D6__NAND_DATA06   0xb0b1
+				MX6QDL_PAD_NANDF_D7__NAND_DATA07   0xb0b1
+				MX6QDL_PAD_SD4_DAT0__NAND_DQS      0x00b1
+			>;
+		};
+	};
+	 */
+	 
+	/* 
+	hdmi_hdcp {
+		pinctrl_hdmi_hdcp_1: hdmihdcpgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL 0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA 0x4001b8b1
+			>;
+		};
+
+		pinctrl_hdmi_hdcp_2: hdmihdcpgrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__HDMI_TX_DDC_SCL 0x4001b8b1
+				MX6QDL_PAD_EIM_D16__HDMI_TX_DDC_SDA 0x4001b8b1
+			>;
+		};
+
+		pinctrl_hdmi_hdcp_3: hdmihdcpgrp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__HDMI_TX_DDC_SCL  0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA 0x4001b8b1
+			>;
+		};
+	};
+	 */
+
+	/*
+	hdmi_cec {
+		pinctrl_hdmi_cec_1: hdmicecgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A25__HDMI_TX_CEC_LINE 0x1f8b0
+			>;
+		};
+
+		pinctrl_hdmi_cec_2: hdmicecgrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE 0x1f8b0
+			>;
+		};
+	};
+	 */
+
+	i2c1 {
+		pinctrl_i2c1_1: i2c1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D28__I2C1_SDA	0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL	0x4001B8B1
+				//MX6QDL_PAD_EIM_D28__I2C1_SDA 0x4001b8b1
+			>;
+		};
+		/*
+		pinctrl_i2c1_2: i2c1grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA 0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL 0x4001b8b1
+			>;
+		};
+		 */
+	};
+
+	/*
+	 * I2C 2 Not used in M300
+	 *
+	i2c2 {
+		pinctrl_i2c2_1: i2c2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__I2C2_SCL 0x4001b8b1
+				MX6QDL_PAD_EIM_D16__I2C2_SDA 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2_2: i2c2grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL 0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2_3: i2c2grp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__I2C2_SCL  0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA 0x4001b8b1
+			>;
+		};
+	};
+	 */
+
+	i2c3 {
+		pinctrl_i2c3_1: i2c3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_5__I2C3_SCL 0x4001b8b1
+				MX6QDL_PAD_GPIO_6__I2C3_SDA 0x4001b8b1
+			>;
+		};
+		/*
+		pinctrl_i2c3_2: i2c3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_3__I2C3_SCL 0x4001b8b1
+				MX6QDL_PAD_GPIO_6__I2C3_SDA 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c3_3: i2c3grp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_5__I2C3_SCL  0x4001b8b1
+				MX6QDL_PAD_GPIO_16__I2C3_SDA 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c3_4: i2c3grp-4 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_3__I2C3_SCL  0x4001b8b1
+				MX6QDL_PAD_EIM_D18__I2C3_SDA 0x4001b8b1
+			>;
+		};
+		 */
+	};
+
+	i2c4 {
+		pinctrl_i2c4_1: i2c4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CS3__I2C4_SDA	0x4001B8B1
+				MX6QDL_PAD_NANDF_WP_B__I2C4_SCL	0x4001B8B1
+			>;
+		};
+	};
+	ipu1 {
+		pinctrl_ipu1_1: ipu1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02        0x10			// LCD HSync
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03        0x10			// LCD VSync
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04        0x80000000	// LCD Contrast
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15       0x10			// LCD DEN
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
+			>;
+		};
+		
+		/*
+		 *	IPU1 is only used for parallel RGB on M300
+		 *
+		pinctrl_ipu1_2: ipu1grp-2 { // parallel camera
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12    0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13    0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14    0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15    0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16    0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17    0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18    0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19    0x80000000
+				MX6QDL_PAD_CSI0_DATA_EN__IPU1_CSI0_DATA_EN 0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK   0x80000000
+				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC      0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC     0x80000000
+			>;
+		};
+		 */
+
+		pinctrl_ipu1_3: ipu1grp-3 { /* parallel port 16-bit */
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT4__IPU1_CSI0_DATA04   0x80000000
+				MX6QDL_PAD_CSI0_DAT5__IPU1_CSI0_DATA05   0x80000000
+				MX6QDL_PAD_CSI0_DAT6__IPU1_CSI0_DATA06   0x80000000
+				MX6QDL_PAD_CSI0_DAT7__IPU1_CSI0_DATA07   0x80000000
+				MX6QDL_PAD_CSI0_DAT8__IPU1_CSI0_DATA08   0x80000000
+				MX6QDL_PAD_CSI0_DAT9__IPU1_CSI0_DATA09   0x80000000
+				MX6QDL_PAD_CSI0_DAT10__IPU1_CSI0_DATA10  0x80000000
+				MX6QDL_PAD_CSI0_DAT11__IPU1_CSI0_DATA11  0x80000000
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12  0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13  0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14  0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15  0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16  0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17  0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18  0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19  0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK 0x80000000
+				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC    0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC   0x80000000
+			>;
+		};
+	};
+
+	mlb {
+		pinctrl_mlb_1: mlbgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_3__MLB_CLK  0x71
+				MX6QDL_PAD_GPIO_6__MLB_SIG  0x71
+				MX6QDL_PAD_GPIO_2__MLB_DATA 0x71
+			>;
+		};
+		
+		/*
+		pinctrl_mlb_2: mlbgrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_TXD1__MLB_CLK 0x80000000
+				MX6QDL_PAD_GPIO_6__MLB_SIG    0x80000000
+				MX6QDL_PAD_GPIO_2__MLB_DATA   0x80000000
+			>;
+		};
+		 */
+	};
+
+	pwm1 {
+		pinctrl_pwm1_1: pwm1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT3__PWM1_OUT 0x1b0b1
+			>;
+		};
+	};
+
+	/*
+	pwm3 {
+		pinctrl_pwm3_1: pwm3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_DAT1__PWM3_OUT 0x1b0b1
+			>;
+		};
+	};
+	 */
+
+	spdif {
+		pinctrl_spdif_1: spdifgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__SPDIF_IN 0x1b0b0
+			>;
+		};
+
+		pinctrl_spdif_2: spdifgrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_16__SPDIF_IN  0x1b0b0
+				MX6QDL_PAD_GPIO_17__SPDIF_OUT 0x1b0b0
+			>;
+		};
+	};
+
+	uart1 {
+		pinctrl_uart1_1: uart1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT7__UART1_TX_DATA	0x1b0b1
+				MX6QDL_PAD_SD3_DAT6__UART1_RX_DATA	0x1b0b1
+				MX6QDL_PAD_SD3_DAT0__UART1_CTS_B	0x1b0b1
+				MX6QDL_PAD_SD3_DAT1__UART1_RTS_B	0x1b0b1
+			>;
+		};
+		/*
+		pinctrl_uart1_2: uart1grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT7__UART1_TX_DATA 0x1b0b1
+				MX6QDL_PAD_SD3_DAT6__UART1_RX_DATA 0x1b0b1
+			>;
+		};
+		 */
+	};
+	
+	/*
+	 * UART2 not used in M300
+	 *
+	uart2 {
+		pinctrl_uart2_1: uart2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
+			>;
+		};
+
+		pinctrl_uart2_2: uart2grp-2 { // DTE mode
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_RX_DATA   0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_TX_DATA   0x1b0b1
+				MX6QDL_PAD_EIM_D28__UART2_DTE_CTS_B 0x1b0b1
+				MX6QDL_PAD_EIM_D29__UART2_DTE_RTS_B 0x1b0b1
+			>;
+		};
+	};
+	*/
+	
+	/*
+	 * UART3 not used in M300
+	 *
+	uart3 {
+		pinctrl_uart3_1: uart3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CLK__UART3_RX_DATA 0x1b0b1
+				MX6QDL_PAD_SD4_CMD__UART3_TX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D30__UART3_CTS_B   0x1b0b1
+				MX6QDL_PAD_EIM_EB3__UART3_RTS_B   0x1b0b1
+			>;
+		};
+	};
+	 */
+	uart4 {
+		pinctrl_uart4_1: uart4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA 0x1b0b1
+				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA 0x1b0b1
+				MX6QDL_PAD_CSI0_DAT17__UART4_CTS_B   0x1b0b1
+				MX6QDL_PAD_CSI0_DAT16__UART4_RTS_B   0x1b0b1
+			>;
+		};
+	};
+
+	uart5 {
+		pinctrl_uart5_1: uart5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT15__UART5_TX_DATA 0x1b0b1
+				MX6QDL_PAD_CSI0_DAT14__UART5_RX_DATA 0x1b0b1
+				MX6QDL_PAD_CSI0_DAT19__UART5_CTS_B   0x1b0b1
+				MX6QDL_PAD_CSI0_DAT18__UART5_RTS_B   0x1b0b1
+			>;
+		};
+	};
+	
+	usbh1 {
+		pinctrl_usbh1_1: usbh1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D30__USB_H1_OC	0x17059
+				MX6QDL_PAD_EIM_D31__USB_H1_PWR	0x17059
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_1: usbotggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D21__USB_OTG_OC  0x17059
+				MX6QDL_PAD_EIM_D22__USB_OTG_PWR 0x17059
+				MX6QDL_PAD_GPIO_1__USB_OTG_ID   0x17059
+			>;
+		};
+		/*
+		pinctrl_usbotg_2: usbotggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID 0x17059
+			>;
+		};
+		 */
+	};
+
+	/*
+	 * USB H2 not used in M300
+	 *
+	usbh2 {
+		pinctrl_usbh2_1: usbh2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_RGMII_TXC__USB_H2_DATA      0x40013030
+				MX6QDL_PAD_RGMII_TX_CTL__USB_H2_STROBE 0x40013030
+			>;
+		};
+
+		pinctrl_usbh2_2: usbh2grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_RGMII_TX_CTL__USB_H2_STROBE 0x40017030
+			>;
+		};
+	};
+	 */
+	
+	/*
+	 * USB H3 not used in M300
+	 *
+	usbh3 {
+		pinctrl_usbh3_1: usbh3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_RGMII_RX_CTL__USB_H3_DATA 0x40013030
+				MX6QDL_PAD_RGMII_RXC__USB_H3_STROBE  0x40013030
+			>;
+		};
+
+		pinctrl_usbh3_2: usbh3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_RGMII_RXC__USB_H3_STROBE 0x40017030
+			>;
+		};
+	};
+	 */
+	/*
+	 * USDHC1 - Not used in M300
+	 *
+	usdhc1 {
+		pinctrl_usdhc1_1: usdhc1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD    0x17071
+				MX6QDL_PAD_SD1_CLK__SD1_CLK    0x10071
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0 0x17071
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1 0x17071
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2 0x17071
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3 0x17071
+			>;
+		};
+	};
+	 */
+	
+	/*
+	 * USDHC2 - Used in 4-bit mode as boot device in M300
+	 *
+	 * Control Value (0x17059):
+	 *		0x10000	(1 << 16) - Hys(teresis) - Schmitt trigger compatible
+	 *		0x04000 (1 << 14) - 47k Pull Up
+	 *		0x02000 (1 << 13) - PUE - (Pull up) enabled
+	 *		0x03000 (1 << 12) - PKE - (Keeper) enabled
+	 *		0x00040 (1 << 6)  - Low Speed (<50MHz)
+	 *		0x00018 (3 << 3)  - Drive Strength 80 Ohm
+	 *		0x00001 (1 << 0)  - Fast slew rate
+	 */
+	usdhc2 {
+		pinctrl_usdhc2_1: usdhc2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0	0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1	0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2	0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3	0x17059
+				//MX6QDL_PAD_NANDF_D4__SD2_DATA4	0x17059
+				//MX6QDL_PAD_NANDF_D5__SD2_DATA5	0x17059
+				//MX6QDL_PAD_NANDF_D6__SD2_DATA6	0x17059
+				//MX6QDL_PAD_NANDF_D7__SD2_DATA7	0x17059
+				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10059
+				MX6QDL_PAD_GPIO_4__SD2_CD_B		0x17059
+			>;
+		};
+		/*
+		pinctrl_usdhc2_2: usdhc2grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD    0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK    0x10059
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0 0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1 0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2 0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3 0x17059
+			>;
+		};
+		 */
+	};
+	
+	/*
+	usdhc3 {
+		pinctrl_usdhc3_1: usdhc3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD    0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK    0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x17059
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x17059
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x17059
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x17059
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x17059
+			>;
+		};
+
+		pinctrl_usdhc3_1_100mhz: usdhc3grp-1-100mhz { // 100Mhz
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD 0x170B9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK 0x100B9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x170B9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x170B9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x170B9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x170B9
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x170B9
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x170B9
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x170B9
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x170B9
+			>;
+		};
+
+		pinctrl_usdhc3_1_200mhz: usdhc3grp-1-200mhz { // 200Mhz
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD 0x170F9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK 0x100F9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x170F9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x170F9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x170F9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x170F9
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x170F9
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x170F9
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x170F9
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x170F9
+			>;
+		};
+
+		pinctrl_usdhc3_2: usdhc3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD    0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK    0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x17059
+			>;
+		};
+	};
+	*/
+	
+	/*
+	 *	USDHC4 - External (off module) SD card socket (8-bit)
+	 *	Re-ordered to match M300 schematic
+	 */	
+	usdhc4 {
+		pinctrl_usdhc4_1: usdhc4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0  0x17059
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1  0x17059
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2  0x17059
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3  0x17059
+				MX6QDL_PAD_SD4_DAT4__SD4_DATA4  0x17059
+				MX6QDL_PAD_SD4_DAT5__SD4_DATA5  0x17059
+				MX6QDL_PAD_SD4_DAT6__SD4_DATA6  0x17059
+				MX6QDL_PAD_SD4_DAT7__SD4_DATA7  0x17059
+				MX6QDL_PAD_NANDF_ALE__SD4_RESET 0x17059	// Goes to CD pin on socket
+				MX6QDL_PAD_SD4_CLK__SD4_CLK     0x10059
+				MX6QDL_PAD_SD4_CMD__SD4_CMD     0x17059
+			>;
+		};
+		/*
+		pinctrl_usdhc4_2: usdhc4grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CMD__SD4_CMD    0x17059
+				MX6QDL_PAD_SD4_CLK__SD4_CLK    0x10059
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0 0x17059
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1 0x17059
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2 0x17059
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3 0x17059
+			>;
+		};
+		 */
+	};
+	/*
+	weim {
+		pinctrl_weim_cs0_1: weim_cs0grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_CS0__EIM_CS0_B   0xb0b1
+			>;
+		};
+		
+		pinctrl_weim_nor_1: weim_norgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_OE__EIM_OE_B     0xb0b1
+				MX6QDL_PAD_EIM_RW__EIM_RW       0xb0b1
+				MX6QDL_PAD_EIM_WAIT__EIM_WAIT_B 0xb060
+				// data
+				MX6QDL_PAD_EIM_D16__EIM_DATA16 0x1b0b0
+				MX6QDL_PAD_EIM_D17__EIM_DATA17 0x1b0b0
+				MX6QDL_PAD_EIM_D18__EIM_DATA18 0x1b0b0
+				MX6QDL_PAD_EIM_D19__EIM_DATA19 0x1b0b0
+				MX6QDL_PAD_EIM_D20__EIM_DATA20 0x1b0b0
+				MX6QDL_PAD_EIM_D21__EIM_DATA21 0x1b0b0
+				MX6QDL_PAD_EIM_D22__EIM_DATA22 0x1b0b0
+				MX6QDL_PAD_EIM_D23__EIM_DATA23 0x1b0b0
+				MX6QDL_PAD_EIM_D24__EIM_DATA24 0x1b0b0
+				MX6QDL_PAD_EIM_D25__EIM_DATA25 0x1b0b0
+				MX6QDL_PAD_EIM_D26__EIM_DATA26 0x1b0b0
+				MX6QDL_PAD_EIM_D27__EIM_DATA27 0x1b0b0
+				MX6QDL_PAD_EIM_D28__EIM_DATA28 0x1b0b0
+				MX6QDL_PAD_EIM_D29__EIM_DATA29 0x1b0b0
+				MX6QDL_PAD_EIM_D30__EIM_DATA30 0x1b0b0
+				MX6QDL_PAD_EIM_D31__EIM_DATA31 0x1b0b0
+				// address
+				MX6QDL_PAD_EIM_A23__EIM_ADDR23 0xb0b1
+				MX6QDL_PAD_EIM_A22__EIM_ADDR22 0xb0b1
+				MX6QDL_PAD_EIM_A21__EIM_ADDR21 0xb0b1
+				MX6QDL_PAD_EIM_A20__EIM_ADDR20 0xb0b1
+				MX6QDL_PAD_EIM_A19__EIM_ADDR19 0xb0b1
+				MX6QDL_PAD_EIM_A18__EIM_ADDR18 0xb0b1
+				MX6QDL_PAD_EIM_A17__EIM_ADDR17 0xb0b1
+				MX6QDL_PAD_EIM_A16__EIM_ADDR16 0xb0b1
+				MX6QDL_PAD_EIM_DA15__EIM_AD15  0xb0b1
+				MX6QDL_PAD_EIM_DA14__EIM_AD14  0xb0b1
+				MX6QDL_PAD_EIM_DA13__EIM_AD13  0xb0b1
+				MX6QDL_PAD_EIM_DA12__EIM_AD12  0xb0b1
+				MX6QDL_PAD_EIM_DA11__EIM_AD11  0xb0b1
+				MX6QDL_PAD_EIM_DA10__EIM_AD10  0xb0b1
+				MX6QDL_PAD_EIM_DA9__EIM_AD09   0xb0b1
+				MX6QDL_PAD_EIM_DA8__EIM_AD08   0xb0b1
+				MX6QDL_PAD_EIM_DA7__EIM_AD07   0xb0b1
+				MX6QDL_PAD_EIM_DA6__EIM_AD06   0xb0b1
+				MX6QDL_PAD_EIM_DA5__EIM_AD05   0xb0b1
+				MX6QDL_PAD_EIM_DA4__EIM_AD04   0xb0b1
+				MX6QDL_PAD_EIM_DA3__EIM_AD03   0xb0b1
+				MX6QDL_PAD_EIM_DA2__EIM_AD02   0xb0b1
+				MX6QDL_PAD_EIM_DA1__EIM_AD01   0xb0b1
+				MX6QDL_PAD_EIM_DA0__EIM_AD00   0xb0b1
+			>;
+		};
+		
+	};
+	 */
+};
diff --git a/arch/arm/boot/dts/imx6m300.dts b/arch/arm/boot/dts/imx6m300.dts
new file mode 100644
index 0000000..18bd3f8
--- /dev/null
+++ b/arch/arm/boot/dts/imx6m300.dts
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2013-2015, Megger Instruments, Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6m300-dl.dtsi"
+#include "imx6m300.dtsi"
+#include "imx6m300-common.dtsi"
+
+/ {
+	model = "Megger Instruments i.MX6 DualLite Mithras 300 Board";
+	compatible = "fsl,imx6m300", "fsl,imx6dl";
+};
+
+
diff --git a/arch/arm/boot/dts/imx6m300.dtsi b/arch/arm/boot/dts/imx6m300.dtsi
new file mode 100644
index 0000000..73af74a
--- /dev/null
+++ b/arch/arm/boot/dts/imx6m300.dtsi
@@ -0,0 +1,545 @@
+/*
+ * Copyright 2015 Megger Instruments, Ltd
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+	};
+
+	/*
+	 * Mithras M300 has 2GB DDR3
+	 */
+	memory {
+		reg = <0x10000000 0x80000000>;
+	};
+	
+	/*
+	 *	Add the regulators for the SoC and USB
+	 */
+	regulators {
+		compatible = "simple-bus";
+		
+		sw1a_reg: sw1ab {
+			regulator-min-microvolt = <300000>;
+			regulator-max-microvolt = <1500000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+		
+		sw1c_reg: sw1c {
+			regulator-min-microvolt = <300000>;
+			regulator-max-microvolt = <1500000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+		
+		reg_usb_h1_vbus: reg_usb_h {
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+		
+		reg_usb_otg_vbus: reg_usb_otg {
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+	};
+
+	//
+	//	LVDS CABC Not implemented on M300
+	//
+	/*
+	hannstar_cabc {
+		compatible = "hannstar,cabc";
+
+		lvds0 {
+			gpios = <&gpio6 15 GPIO_ACTIVE_HIGH>;
+		};
+
+		lvds1 {
+			gpios = <&gpio6 16 GPIO_ACTIVE_HIGH>;
+		};
+	};
+	*/
+	
+	leds {
+		compatible = "gpio-leds";
+
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		power {
+			label = "Power Button";
+			gpios = <&gpio3 29 1>;
+			linux,code = <116>; /* KEY_POWER */
+			gpio-key,wakeup;
+		};
+
+		volume-up {
+			label = "Volume Up";
+			gpios = <&gpio1 4 1>;
+			linux,code = <115>; /* KEY_VOLUMEUP */
+		};
+
+		volume-down {
+			label = "Volume Down";
+			gpios = <&gpio1 5 1>;
+			linux,code = <114>; /* KEY_VOLUMEDOWN */
+		};
+	};
+	//
+	//	SGTL5000 Audio Codec, attached to AUD 3 (SSI3) and I2C 1
+	//
+	sound {
+		compatible = "fsl,imxm300-sgtl5000",
+			   "fsl,imx-audio-sgtl5000";
+		model = "sgtl5000-audio";
+		ssi-controller = <&ssi3>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MIC_IN", "Mic Jack",
+			"Mic Jack", "Mic Bias",
+			"Headphone Jack", "HP_OUT";
+		mux-int-port = <1>;
+		mux-ext-port = <3>;
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+	//
+	//	7" LVDS Display (800x480 - WVGA)
+	//
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LVDS7-800x480";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+	//
+	//	4.3" Parallel RGB Display (480x272 - WQVGA)
+	//
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LCD4.3-480x272";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+	//
+	//	7" Parallel RGB Display (800x480 - WVGA)
+	//
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LCD7-800x480";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+	//
+	//	10" Parallel RGB Display (1024x600 - WSVGA)
+	//
+	mxcfb5: fb@4 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB24";
+		mode_str = "LCD10-1024x600";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB24";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_1>;
+		status = "okay";
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_cap_1 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <1>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+	/*
+	mipi_dsi_reset: mipi-dsi-reset {
+		compatible = "gpio-reset";
+		reset-gpios = <&gpio6 11 GPIO_ACTIVE_LOW>;
+		reset-delay-us = <50>;
+		#reset-cells = <0>;
+	};
+	 */
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_1>;
+	status = "okay";
+};
+
+&cpu0 {
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1c_reg>;
+	pu-supply = <&pu_dummy>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+//
+//	SPI1 - With two select lines (ECSPI1_SS1 and ECSPI1_SS2) on M300 
+//
+//	M300 carrier board has 1MB NOR FLASH on SPI, as two 4Mb devices on
+//	SS1 and SS2
+//
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio4 9 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_1>;
+	status = "okay";
+	
+	/*
+	 *	Serial flash device on Mithras carrier board - used to test the SPI interface
+	 *	The device is actually AT25SF041 (4Mb) - the kernel detects it as MR25H256
+	 */
+	flash: mr25h256@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,m25p32";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+};
+
+//
+//	Fast Ethernet Connector - Implemented as 10/100Mbs on M300 (not 1Gbs); PHY is 
+//	KSZ8081RNBIA RMII mode
+//
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_1>;
+	phy-mode = "rmii";
+	status = "okay";
+};
+
+//
+//	General Power Controller
+//
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0xf>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,ldo-bypass = <1>; /* use ldo-bypass, u-boot will check it and configure */
+	fsl,wdog-reset = <2>; /* watchdog select of reset source */
+	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+//
+//	Graphics Processor
+//
+&gpu {
+	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+//
+//	Audio codec Control I2C - Port 1 Address 0x14
+//
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_1>;
+	status = "okay";
+
+	codec: sgtl5000@14 {
+		compatible = "wlf,sgtl5000";
+		reg = <0x14>;
+		clocks = <&clks 201>;
+		amic-mono;
+       };
+
+};
+
+//
+//	I2C Port 3 - Goes to PCIe
+//
+&i2c3 {
+        clock-frequency = <100000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_i2c3_1>;
+        status = "okay";
+};
+
+//
+//	I2C Port 4
+//
+&i2c4 {
+        clock-frequency = <100000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_i2c4_1>;
+        status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>;
+
+	hog {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_4__GPIO1_IO04   0x80000000
+				//MX6QDL_PAD_GPIO_5__GPIO1_IO05   0x80000000	// Used for I2C3 SCLK
+				MX6QDL_PAD_NANDF_D0__GPIO2_IO00 0x80000000
+				MX6QDL_PAD_NANDF_D1__GPIO2_IO01 0x80000000
+				MX6QDL_PAD_NANDF_D2__GPIO2_IO02 0x80000000
+				MX6QDL_PAD_NANDF_D3__GPIO2_IO03 0x80000000
+				//MX6QDL_PAD_NANDF_ALE__GPIO6_IO08 0x80000000	// Used for SD4 (CD Pin)
+				MX6QDL_PAD_NANDF_CLE__GPIO6_IO07 0x80000000
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1    0x130b0
+				//MX6QDL_PAD_NANDF_CS2__GPIO6_IO15 0x80000000
+				//MX6QDL_PAD_NANDF_CS3__GPIO6_IO16 0x80000000
+				MX6QDL_PAD_EIM_D26__GPIO3_IO26 0x80000000
+				MX6QDL_PAD_EIM_CS1__GPIO2_IO24 0x80000000
+				//MX6QDL_PAD_ENET_RXD0__GPIO1_IO27 0x80000000
+				MX6QDL_PAD_EIM_A25__GPIO5_IO02 0x80000000
+				MX6QDL_PAD_EIM_D23__GPIO3_IO23 0x80000000
+				//MX6QDL_PAD_ENET_TXD1__GPIO1_IO29 0x80000000
+				MX6QDL_PAD_EIM_D22__GPIO3_IO22  0x80000000
+				MX6QDL_PAD_NANDF_CS0__GPIO6_IO11 0x80000000
+				MX6QDL_PAD_NANDF_CS1__GPIO6_IO14 0x80000000
+				MX6QDL_PAD_EIM_EB3__GPIO2_IO31 0x80000000
+				//MX6QDL_PAD_EIM_D16__GPIO3_IO16 0x80000000
+				MX6QDL_PAD_EIM_DA9__GPIO3_IO09 0x80000000
+				MX6QDL_PAD_EIM_D29__GPIO3_IO29 0x80000000
+				MX6QDL_PAD_SD3_RST__GPIO7_IO08 0x80000000
+				//MX6QDL_PAD_GPIO_9__GPIO1_IO09 0x80000000
+				MX6QDL_PAD_GPIO_1__WDOG2_B 0x80000000
+				//MX6QDL_PAD_GPIO_2__GPIO1_IO02 0x80000000
+			>;
+		};
+	};
+};
+
+&ldb {
+	ipu_id = <1>;
+	disp_id = <1>;
+	ext_ref = <1>;
+	mode = "sep1";
+	sec_ipu_id = <1>;
+	sec_disp_id = <0>;
+	status = "okay";
+};
+
+//
+//	MIPI Camera Interface
+//
+&mipi_csi {
+	status = "okay";
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <0>;
+	lanes = <2>;
+};
+
+/*
+ *	MIPI Display Interface - Not available on M300
+ *
+&mipi_dsi {
+	dev_id = <0>;
+	disp_id = <1>;
+	lcd_panel = "TRULY-WVGA";
+	disp-power-on-supply = <&reg_mipi_dsi_pwr_on>;
+	resets = <&mipi_dsi_reset>;
+	status = "disabled";
+};
+ */
+
+//
+//	PCIe 
+//
+&pcie {
+	power-on-gpio = <&gpio5 20 0>;
+	status = "okay";
+};
+
+//
+//	PWM1 - LVDS Backlight Brightness Control 
+//
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1_1>;
+	status = "okay";
+};
+
+//
+//	SSI1 (I2S 1) - Not available on M300
+//
+&ssi1 {
+	fsl,mode = "i2s-slave";
+	status = "disabled";
+};
+
+//
+//	UART1 - (M300 name UART0) - Debug console
+//
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+//
+//	UART4 - (M300 name UART1) - Instrument control
+//
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4_1>;
+	status = "okay";
+};
+
+//
+//	UART5 - (M300 name UART2)
+//
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5_1>;
+	status = "okay";
+};
+
+//
+//	USB H1 - USB2.0 Host port
+//
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbh1_1>;
+	status = "okay";
+};
+
+//
+//	USB OTG - USB 2.0 OTG port
+//
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_1>;
+	disable-over-current;
+	status = "okay";
+};
+
+//
+//	uSD HC 2 - M300 Boot device on module (1 or 4-bit mode only)
+//
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_1>;
+	//
+	//	Card detect (GPIO1-IO4) pulled low, no write protect
+	//
+	cd-gpios = <&gpio1 4 0>;
+	//wp-gpios = <&gpio2 3 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+/*
+ *	uSD HC 3 - Not available on M300
+ *
+&usdhc3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc3_1>;
+	cd-gpios = <&gpio2 0 0>;
+	wp-gpios = <&gpio2 1 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "disabled";
+};
+ */
+ 
+//
+//	uSD HC 4 - Extension SD card interface (1, 4 or 8-bit)
+//
+&usdhc4 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4_1>;
+	//cd-gpios = <&gpio6 8 0>;
+	bus-width = <8>;
+    non-removable;
+    no-1-8-v;
+	keep-power-in-suspend;
+    status = "okay";
+};
+
+//
+//	Video Processor
+//
+&vpu {
+	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
diff --git a/arch/arm/boot/dts/imx6q-sabresd.dts b/arch/arm/boot/dts/imx6q-sabresd.dts
index 072e7d3..5e5ff56 100644
--- a/arch/arm/boot/dts/imx6q-sabresd.dts
+++ b/arch/arm/boot/dts/imx6q-sabresd.dts
@@ -26,6 +26,107 @@
 	offset-usb-charger = <1685>;
 };
 
+&i2c2 {
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
 &mxcfb1 {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
index 66b6145..5d774e5 100644
--- a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
@@ -405,105 +405,6 @@
 		mclk_source = <0>;
 	};
 
-	pmic: pfuze100@08 {
-		compatible = "fsl,pfuze100";
-		reg = <0x08>;
-
-		regulators {
-			sw1a_reg: sw1ab {
-				regulator-min-microvolt = <300000>;
-				regulator-max-microvolt = <1875000>;
-				regulator-boot-on;
-				regulator-always-on;
-				regulator-ramp-delay = <6250>;
-			};
-
-			sw1c_reg: sw1c {
-				regulator-min-microvolt = <300000>;
-				regulator-max-microvolt = <1875000>;
-				regulator-boot-on;
-				regulator-always-on;
-				regulator-ramp-delay = <6250>;
-			};
-
-			sw2_reg: sw2 {
-				regulator-min-microvolt = <800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			sw3a_reg: sw3a {
-				regulator-min-microvolt = <400000>;
-				regulator-max-microvolt = <1975000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			sw3b_reg: sw3b {
-				regulator-min-microvolt = <400000>;
-				regulator-max-microvolt = <1975000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			sw4_reg: sw4 {
-				regulator-min-microvolt = <800000>;
-				regulator-max-microvolt = <3300000>;
-			};
-
-			swbst_reg: swbst {
-				regulator-min-microvolt = <5000000>;
-				regulator-max-microvolt = <5150000>;
-			};
-
-			snvs_reg: vsnvs {
-				regulator-min-microvolt = <1000000>;
-				regulator-max-microvolt = <3000000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			vref_reg: vrefddr {
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			vgen1_reg: vgen1 {
-				regulator-min-microvolt = <800000>;
-				regulator-max-microvolt = <1550000>;
-			};
-
-			vgen2_reg: vgen2 {
-				regulator-min-microvolt = <800000>;
-				regulator-max-microvolt = <1550000>;
-			};
-
-			vgen3_reg: vgen3 {
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-			};
-
-			vgen4_reg: vgen4 {
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-			};
-
-			vgen5_reg: vgen5 {
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-			};
-
-			vgen6_reg: vgen6 {
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-			};
-		};
-	};
-
         egalax_ts@04 {
                 compatible = "eeti,egalax_ts";
                 reg = <0x04>;
diff --git a/arch/arm/boot/dts/imx6sl-evk-common.dtsi b/arch/arm/boot/dts/imx6sl-evk-common.dtsi
new file mode 100644
index 0000000..a1a3969
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sl-evk-common.dtsi
@@ -0,0 +1,504 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	memory {
+		reg = <0x80000000 0x40000000>;
+	};
+
+	battery: max8903@0 {
+		compatible = "fsl,max8903-charger";
+		pinctrl-names = "default";
+		dok_input = <&gpio4 13 1>;
+		uok_input = <&gpio4 13 1>;
+		chg_input = <&gpio4 15 1>;
+		flt_input = <&gpio4 14 1>;
+		fsl,dcm_always_high;
+		fsl,dc_valid;
+		fsl,adc_disable;
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_lcd_3v3: lcd-3v3 {
+			compatible = "regulator-fixed";
+			regulator-name = "lcd-3v3";
+			gpio = <&gpio4 3 0>;
+			enable-active-high;
+		};
+
+		reg_aud3v: wm8962_supply_3v15 {
+			compatible = "regulator-fixed";
+			regulator-name = "wm8962-supply-3v15";
+			regulator-min-microvolt = <3150000>;
+			regulator-max-microvolt = <3150000>;
+			regulator-boot-on;
+		};
+
+		reg_aud4v: wm8962_supply_4v2 {
+			compatible = "regulator-fixed";
+			regulator-name = "wm8962-supply-4v2";
+			regulator-min-microvolt = <4325000>;
+			regulator-max-microvolt = <4325000>;
+			regulator-boot-on;
+		};
+
+		reg_usb_otg1_vbus: usb_otg1_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 0 0>;
+			enable-active-high;
+		};
+
+		reg_usb_otg2_vbus: usb_otg2_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg2_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 2 0>;
+			enable-active-high;
+		};
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+	};
+
+	csi_v4l2_cap {
+		compatible = "fsl,imx6sl-csi-v4l2";
+		status = "disabled";
+	};
+
+	pxp_v4l2_out {
+		compatible = "fsl,imx6sl-pxp-v4l2";
+		status = "okay";
+	};
+
+	sound {
+		compatible = "fsl,imx6q-sabresd-wm8962",
+			   "fsl,imx-audio-wm8962";
+		model = "wm8962-audio";
+		ssi-controller = <&ssi2>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"Headphone Jack", "HPOUTL",
+			"Headphone Jack", "HPOUTR",
+			"Ext Spk", "SPKOUTL",
+			"Ext Spk", "SPKOUTR",
+			"AMIC", "MICBIAS",
+			"IN3R", "AMIC";
+		amic-mono;
+		mux-int-port = <2>;
+		mux-ext-port = <3>;
+		hp-det-gpios = <&gpio4 19 1>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+			   "fsl,imx6sl-evk-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-out;
+	};
+
+	sii902x_reset: sii902x-reset {
+		compatible = "gpio-reset";
+		reset-gpios = <&gpio2 19 1>;
+		reset-delay-us = <100000>;
+		#reset-cells = <0>;
+	};
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_1>;
+	status = "okay";
+};
+
+&csi {
+	status = "disabled";
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio4 11 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_1>;
+	status = "okay";
+
+	flash: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,m25p32";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+};
+
+&epdc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_epdc_0>;
+	V3P3-supply = <&V3P3_reg>;
+	VCOM-supply = <&VCOM_reg>;
+	DISPLAY-supply = <&DISPLAY_reg>;
+	status = "okay";
+};
+
+&cpu0 {
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1c_reg>;
+	pu-supply = <&pu_dummy>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&fec {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_fec_1>;
+	pinctrl-1 = <&pinctrl_fec_1_sleep>;
+	phy-mode = "rmii";
+	phy-reset-gpios = <&gpio4 21 0>; /* GPIO4_21 */
+	phy-reset-duration = <1>;
+	status = "okay";
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0xf>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,ldo-bypass = <1>; /* use ldo-bypass, u-boot will check it and configure */
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpu {
+	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_1>;
+	status = "okay";
+
+	elan@10 {
+		compatible = "elan,elan-touch";
+		reg = <0x10>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <10 2>;
+		gpio_elan_cs = <&gpio2 9 0>;
+		gpio_elan_rst = <&gpio4 4 0>;
+		gpio_intr = <&gpio2 10 0>;
+		status = "okay";
+	};
+
+	max17135@48 {
+		compatible = "maxim,max17135";
+		reg = <0x48>;
+		vneg_pwrup = <1>;
+		gvee_pwrup = <2>;
+		vpos_pwrup = <10>;
+		gvdd_pwrup = <12>;
+		gvdd_pwrdn = <1>;
+		vpos_pwrdn = <2>;
+		gvee_pwrdn = <8>;
+		vneg_pwrdn = <10>;
+		gpio_pmic_pwrgood = <&gpio2 13 0>;
+		gpio_pmic_vcom_ctrl = <&gpio2 3 0>;
+		gpio_pmic_wakeup = <&gpio2 14 0>;
+		gpio_pmic_v3p3 = <&gpio2 7 0>;
+		gpio_pmic_intr = <&gpio2 12 0>;
+
+		regulators {
+			DISPLAY_reg: DISPLAY {
+				regulator-name = "DISPLAY";
+			};
+
+			GVDD_reg: GVDD {
+				/* 20v */
+				regulator-name = "GVDD";
+			};
+
+			GVEE_reg: GVEE {
+				/* -22v */
+				regulator-name = "GVEE";
+			};
+
+			HVINN_reg: HVINN {
+				/* -22v */
+				regulator-name = "HVINN";
+			};
+
+			HVINP_reg: HVINP {
+				/* 20v */
+				regulator-name = "HVINP";
+			};
+
+			VCOM_reg: VCOM {
+				regulator-name = "VCOM";
+				/* 2's-compliment, -4325000 */
+				regulator-min-microvolt = <0xffbe0178>;
+				/* 2's-compliment, -500000 */
+				regulator-max-microvolt = <0xfff85ee0>;
+			};
+
+			VNEG_reg: VNEG {
+				/* -15v */
+				regulator-name = "VNEG";
+			};
+
+			VPOS_reg: VPOS {
+				/* 15v */
+				regulator-name = "VPOS";
+			};
+
+			V3P3_reg: V3P3 {
+				regulator-name = "V3P3";
+			};
+		};
+	};
+
+	mma8450@1c {
+		compatible = "fsl,mma8450";
+		reg = <0x1c>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_1>;
+	status = "okay";
+
+	codec: wm8962@1a {
+		compatible = "wlf,wm8962";
+		reg = <0x1a>;
+		clocks = <&clks IMX6SL_CLK_EXTERN_AUDIO>;
+		DCVDD-supply = <&vgen3_reg>;
+		DBVDD-supply = <&reg_aud3v>;
+		AVDD-supply = <&vgen3_reg>;
+		CPVDD-supply = <&vgen3_reg>;
+		MICVDD-supply = <&reg_aud3v>;
+		PLLVDD-supply = <&vgen3_reg>;
+		SPKVDD1-supply = <&reg_aud4v>;
+		SPKVDD2-supply = <&reg_aud4v>;
+		amic-mono;
+	};
+
+	sii902x@39 {
+		compatible = "SiI,sii902x";
+		interrupt-parent = <&gpio2>;
+		interrupts = <10 2>;
+		mode_str ="1280x720M@60";
+		bits-per-pixel = <32>;
+		resets = <&sii902x_reset>;
+		reg = <0x39>;
+	};
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_1>;
+	status = "disabled";
+
+	ov564x: ov564x@3c {
+		compatible = "ovti,ov564x";
+		reg = <0x3c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_0>;
+		clocks = <&clks IMX6SL_CLK_CSI>;
+		clock-names = "csi_mclk";
+		AVDD-supply = <&vgen6_reg>;  /* 2.8v */
+		DVDD-supply = <&vgen2_reg>;  /* 1.5v*/
+		pwn-gpios = <&gpio1 25 1>;
+		rst-gpios = <&gpio1 26 0>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_hog>;
+	pinctrl-1 = <&pinctrl_hog_sleep>;
+
+	hog {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				MX6SL_PAD_KEY_ROW7__GPIO4_IO07    0x17059
+				MX6SL_PAD_KEY_COL7__GPIO4_IO06    0x17059
+				MX6SL_PAD_SD2_DAT7__GPIO5_IO00    0x17059
+				MX6SL_PAD_SD2_DAT6__GPIO4_IO29    0x17059
+				MX6SL_PAD_REF_CLK_32K__GPIO3_IO22 0x17059
+				MX6SL_PAD_FEC_TX_CLK__GPIO4_IO21  0x80000000
+				MX6SL_PAD_KEY_ROW5__GPIO4_IO03	  0x110b0
+				MX6SL_PAD_EPDC_VCOM0__GPIO2_IO03  0x80000000
+				MX6SL_PAD_EPDC_PWRSTAT__GPIO2_IO13 0x80000000
+				MX6SL_PAD_EPDC_PWRCTRL0__GPIO2_IO07 0x80000000
+				MX6SL_PAD_EPDC_PWRWAKEUP__GPIO2_IO14 0x80000000
+				MX6SL_PAD_EPDC_PWRINT__GPIO2_IO12 0x80000000
+				MX6SL_PAD_EPDC_PWRCTRL3__GPIO2_IO10 0x170b0
+				MX6SL_PAD_EPDC_PWRCTRL2__GPIO2_IO09 0x80000000
+				MX6SL_PAD_KEY_COL6__GPIO4_IO04    0x110b0
+				MX6SL_PAD_ECSPI2_MISO__GPIO4_IO14 0x17000
+				MX6SL_PAD_ECSPI2_MOSI__GPIO4_IO13 0x17000
+				MX6SL_PAD_ECSPI2_SS0__GPIO4_IO15  0x17000
+				MX6SL_PAD_FEC_RX_ER__GPIO4_IO19   0x1b0b0
+				MX6SL_PAD_LCD_RESET__GPIO2_IO19 0x1b0b0
+				MX6SL_PAD_KEY_COL4__GPIO4_IO00	0x80000000
+				MX6SL_PAD_KEY_COL5__GPIO4_IO02	0x80000000
+			>;
+		};
+
+		pinctrl_hog_sleep: hoggrp_sleep {
+			fsl,pins = <
+				MX6SL_PAD_KEY_ROW5__GPIO4_IO03	  0x3080
+				MX6SL_PAD_KEY_COL6__GPIO4_IO04 	  0x3080
+				MX6SL_PAD_LCD_RESET__GPIO2_IO19   0x3080
+			>;
+		};
+	};
+};
+
+&kpp {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_kpp_1>;
+	pinctrl-1 = <&pinctrl_kpp_1_sleep>;
+	linux,keymap = <
+			0x00000067      /* KEY_UP */
+			0x0001006c      /* KEY_DOWN */
+			0x0002001c      /* KEY_ENTER */
+			0x01000066      /* KEY_HOME */
+			0x0101006a      /* KEY_RIGHT */
+			0x01020069      /* KEY_LEFT */
+			0x02000072      /* KEY_VOLUMEDOWN */
+			0x02010073      /* KEY_VOLUMEUP */
+		>;
+        status = "okay";
+};
+
+&lcdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat_0
+		     &pinctrl_lcdif_ctrl_0>;
+	lcd-supply = <&reg_lcd_3v3>;
+	display = <&display>;
+	status = "okay";
+
+	display: display {
+		bits-per-pixel = <16>;
+		bus-width = <24>;
+
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: timing0 {
+				clock-frequency = <33500000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <89>;
+				hfront-porch = <164>;
+				vback-porch = <23>;
+				vfront-porch = <10>;
+				hsync-len = <10>;
+				vsync-len = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <0>;
+			};
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_pwm1_0>;
+	pinctrl-1 = <&pinctrl_pwm1_0_sleep>;
+	status = "okay";
+};
+
+&pxp {
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_1>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg1_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg1_1>;
+	disable-over-current;
+	imx6-usb-charger-detection;
+	status = "okay";
+};
+
+&usbotg2 {
+	vbus-supply = <&reg_usb_otg2_vbus>;
+	dr_mode = "host";
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1_1>;
+	pinctrl-1 = <&pinctrl_usdhc1_1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_1_200mhz>;
+	bus-width = <8>;
+	cd-gpios = <&gpio4 7 0>;
+	wp-gpios = <&gpio4 6 0>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2_1>;
+	pinctrl-1 = <&pinctrl_usdhc2_1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc2_1_200mhz>;
+	cd-gpios = <&gpio5 0 0>;
+	wp-gpios = <&gpio4 29 0>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3_1>;
+	pinctrl-1 = <&pinctrl_usdhc3_1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_1_200mhz>;
+	cd-gpios = <&gpio3 22 0>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/imx6sl-evk-pf200.dts b/arch/arm/boot/dts/imx6sl-evk-pf200.dts
new file mode 100644
index 0000000..55d3081
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sl-evk-pf200.dts
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6sl.dtsi"
+#include "imx6sl-evk-common.dtsi"
+
+/ {
+	model = "Freescale i.MX6 SoloLite EVK Board(PFUZE200)";
+	compatible = "fsl,imx6sl-evk", "fsl,imx6sl";
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpc {
+	fsl,ldo-bypass = <0>; /* use ldo-bypass, u-boot will check it and configure */
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpu {
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&i2c1 {
+	pmic: pfuze200@08 {
+		compatible = "fsl,pfuze200";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/imx6sl-evk.dts b/arch/arm/boot/dts/imx6sl-evk.dts
index 4966f38..ed0ce89 100644
--- a/arch/arm/boot/dts/imx6sl-evk.dts
+++ b/arch/arm/boot/dts/imx6sl-evk.dts
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -9,195 +9,14 @@
 /dts-v1/;
 
 #include "imx6sl.dtsi"
+#include "imx6sl-evk-common.dtsi"
 
 / {
-	model = "Freescale i.MX6 SoloLite EVK Board";
+	model = "Freescale i.MX6 SoloLite EVK Board(PFUZE100)";
 	compatible = "fsl,imx6sl-evk", "fsl,imx6sl";
-
-	memory {
-		reg = <0x80000000 0x40000000>;
-	};
-
-	battery: max8903@0 {
-		compatible = "fsl,max8903-charger";
-		pinctrl-names = "default";
-		dok_input = <&gpio4 13 1>;
-		uok_input = <&gpio4 13 1>;
-		chg_input = <&gpio4 15 1>;
-		flt_input = <&gpio4 14 1>;
-		fsl,dcm_always_high;
-		fsl,dc_valid;
-		fsl,adc_disable;
-		status = "okay";
-	};
-	regulators {
-		compatible = "simple-bus";
-
-		reg_lcd_3v3: lcd-3v3 {
-			compatible = "regulator-fixed";
-			regulator-name = "lcd-3v3";
-			gpio = <&gpio4 3 0>;
-			enable-active-high;
-		};
-
-		reg_aud3v: wm8962_supply_3v15 {
-			compatible = "regulator-fixed";
-			regulator-name = "wm8962-supply-3v15";
-			regulator-min-microvolt = <3150000>;
-			regulator-max-microvolt = <3150000>;
-			regulator-boot-on;
-		};
-
-		reg_aud4v: wm8962_supply_4v2 {
-			compatible = "regulator-fixed";
-			regulator-name = "wm8962-supply-4v2";
-			regulator-min-microvolt = <4325000>;
-			regulator-max-microvolt = <4325000>;
-			regulator-boot-on;
-		};
-
-		reg_usb_otg1_vbus: usb_otg1_vbus {
-			compatible = "regulator-fixed";
-			regulator-name = "usb_otg1_vbus";
-			regulator-min-microvolt = <5000000>;
-			regulator-max-microvolt = <5000000>;
-			gpio = <&gpio4 0 0>;
-			enable-active-high;
-		};
-
-		reg_usb_otg2_vbus: usb_otg2_vbus {
-			compatible = "regulator-fixed";
-			regulator-name = "usb_otg2_vbus";
-			regulator-min-microvolt = <5000000>;
-			regulator-max-microvolt = <5000000>;
-			gpio = <&gpio4 2 0>;
-			enable-active-high;
-		};
-	};
-
-	backlight {
-		compatible = "pwm-backlight";
-		pwms = <&pwm1 0 5000000>;
-		brightness-levels = <0 4 8 16 32 64 128 255>;
-		default-brightness-level = <6>;
-	};
-
-	csi_v4l2_cap {
-		compatible = "fsl,imx6sl-csi-v4l2";
-		status = "disabled";
-	};
-
-	pxp_v4l2_out {
-		compatible = "fsl,imx6sl-pxp-v4l2";
-		status = "okay";
-	};
-
-	sound {
-		compatible = "fsl,imx6q-sabresd-wm8962",
-			   "fsl,imx-audio-wm8962";
-		model = "wm8962-audio";
-		ssi-controller = <&ssi2>;
-		audio-codec = <&codec>;
-		audio-routing =
-			"Headphone Jack", "HPOUTL",
-			"Headphone Jack", "HPOUTR",
-			"Ext Spk", "SPKOUTL",
-			"Ext Spk", "SPKOUTR",
-			"AMIC", "MICBIAS",
-			"IN3R", "AMIC";
-		amic-mono;
-		mux-int-port = <2>;
-		mux-ext-port = <3>;
-		hp-det-gpios = <&gpio4 19 1>;
-	};
-
-	sound-spdif {
-		compatible = "fsl,imx-audio-spdif",
-			   "fsl,imx6sl-evk-spdif";
-		model = "imx-spdif";
-		spdif-controller = <&spdif>;
-		spdif-out;
-	};
-
-	sii902x_reset: sii902x-reset {
-		compatible = "gpio-reset";
-		reset-gpios = <&gpio2 19 1>;
-		reset-delay-us = <100000>;
-		#reset-cells = <0>;
-	};
-};
-
-&audmux {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_audmux_1>;
-	status = "okay";
-};
-
-&csi {
-	status = "disabled";
-};
-
-&ecspi1 {
-	fsl,spi-num-chipselects = <1>;
-	cs-gpios = <&gpio4 11 0>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_ecspi1_1>;
-	status = "okay";
-
-	flash: m25p80@0 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "st,m25p32";
-		spi-max-frequency = <20000000>;
-		reg = <0>;
-	};
-};
-
-&epdc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_epdc_0>;
-	V3P3-supply = <&V3P3_reg>;
-	VCOM-supply = <&VCOM_reg>;
-	DISPLAY-supply = <&DISPLAY_reg>;
-	status = "okay";
-};
-
-&cpu0 {
-	arm-supply = <&sw1a_reg>;
-	soc-supply = <&sw1c_reg>;
-	pu-supply = <&pu_dummy>; /* use pu_dummy if VDDSOC share with VDDPU */
-};
-
-&fec {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&pinctrl_fec_1>;
-	pinctrl-1 = <&pinctrl_fec_1_sleep>;
-	phy-mode = "rmii";
-	phy-reset-gpios = <&gpio4 21 0>; /* GPIO4_21 */
-	phy-reset-duration = <1>;
-	status = "okay";
-};
-
-&gpc {
-	fsl,cpu_pupscr_sw2iso = <0xf>;
-	fsl,cpu_pupscr_sw = <0xf>;
-	fsl,cpu_pdnscr_iso2sw = <0x1>;
-	fsl,cpu_pdnscr_iso = <0x1>;
-	fsl,ldo-bypass = <1>; /* use ldo-bypass, u-boot will check it and configure */
-	fsl,wdog-reset = <1>; /* watchdog select of reset source */
-	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
-};
-
-&gpu {
-	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
 };
 
 &i2c1 {
-	clock-frequency = <100000>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c1_1>;
-	status = "okay";
-
 	pmic: pfuze100@08 {
 		compatible = "fsl,pfuze100";
 		reg = <0x08>;
@@ -297,314 +116,4 @@
 			};
 		};
 	};
-
-	elan@10 {
-		compatible = "elan,elan-touch";
-		reg = <0x10>;
-		interrupt-parent = <&gpio2>;
-		interrupts = <10 2>;
-		gpio_elan_cs = <&gpio2 9 0>;
-		gpio_elan_rst = <&gpio4 4 0>;
-		gpio_intr = <&gpio2 10 0>;
-		status = "okay";
-	};
-
-	max17135@48 {
-		compatible = "maxim,max17135";
-		reg = <0x48>;
-		vneg_pwrup = <1>;
-		gvee_pwrup = <2>;
-		vpos_pwrup = <10>;
-		gvdd_pwrup = <12>;
-		gvdd_pwrdn = <1>;
-		vpos_pwrdn = <2>;
-		gvee_pwrdn = <8>;
-		vneg_pwrdn = <10>;
-		gpio_pmic_pwrgood = <&gpio2 13 0>;
-		gpio_pmic_vcom_ctrl = <&gpio2 3 0>;
-		gpio_pmic_wakeup = <&gpio2 14 0>;
-		gpio_pmic_v3p3 = <&gpio2 7 0>;
-		gpio_pmic_intr = <&gpio2 12 0>;
-
-		regulators {
-			DISPLAY_reg: DISPLAY {
-				regulator-name = "DISPLAY";
-			};
-
-			GVDD_reg: GVDD {
-				/* 20v */
-				regulator-name = "GVDD";
-			};
-
-			GVEE_reg: GVEE {
-				/* -22v */
-				regulator-name = "GVEE";
-			};
-
-			HVINN_reg: HVINN {
-				/* -22v */
-				regulator-name = "HVINN";
-			};
-
-			HVINP_reg: HVINP {
-				/* 20v */
-				regulator-name = "HVINP";
-			};
-
-			VCOM_reg: VCOM {
-				regulator-name = "VCOM";
-				/* 2's-compliment, -4325000 */
-				regulator-min-microvolt = <0xffbe0178>;
-				/* 2's-compliment, -500000 */
-				regulator-max-microvolt = <0xfff85ee0>;
-			};
-
-			VNEG_reg: VNEG {
-				/* -15v */
-				regulator-name = "VNEG";
-			};
-
-			VPOS_reg: VPOS {
-				/* 15v */
-				regulator-name = "VPOS";
-			};
-
-			V3P3_reg: V3P3 {
-				regulator-name = "V3P3";
-			};
-		};
-	};
-
-	mma8450@1c {
-		compatible = "fsl,mma8450";
-		reg = <0x1c>;
-	};
-};
-
-&i2c2 {
-	clock-frequency = <100000>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c2_1>;
-	status = "okay";
-
-	codec: wm8962@1a {
-		compatible = "wlf,wm8962";
-		reg = <0x1a>;
-		clocks = <&clks IMX6SL_CLK_EXTERN_AUDIO>;
-		DCVDD-supply = <&vgen3_reg>;
-		DBVDD-supply = <&reg_aud3v>;
-		AVDD-supply = <&vgen3_reg>;
-		CPVDD-supply = <&vgen3_reg>;
-		MICVDD-supply = <&reg_aud3v>;
-		PLLVDD-supply = <&vgen3_reg>;
-		SPKVDD1-supply = <&reg_aud4v>;
-		SPKVDD2-supply = <&reg_aud4v>;
-		amic-mono;
-	};
-
-	sii902x@39 {
-		compatible = "SiI,sii902x";
-		interrupt-parent = <&gpio2>;
-		interrupts = <10 2>;
-		mode_str ="1280x720M@60";
-		bits-per-pixel = <32>;
-		resets = <&sii902x_reset>;
-		reg = <0x39>;
-	};
-};
-
-&i2c3 {
-	clock-frequency = <100000>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c3_1>;
-	status = "disabled";
-
-	ov564x: ov564x@3c {
-		compatible = "ovti,ov564x";
-		reg = <0x3c>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_csi_0>;
-		clocks = <&clks IMX6SL_CLK_CSI>;
-		clock-names = "csi_mclk";
-		AVDD-supply = <&vgen6_reg>;  /* 2.8v */
-		DVDD-supply = <&vgen2_reg>;  /* 1.5v*/
-		pwn-gpios = <&gpio1 25 1>;
-		rst-gpios = <&gpio1 26 0>;
-		csi_id = <0>;
-		mclk = <24000000>;
-		mclk_source = <0>;
-	};
-};
-
-&iomuxc {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&pinctrl_hog>;
-	pinctrl-1 = <&pinctrl_hog_sleep>;
-
-	hog {
-		pinctrl_hog: hoggrp {
-			fsl,pins = <
-				MX6SL_PAD_KEY_ROW7__GPIO4_IO07    0x17059
-				MX6SL_PAD_KEY_COL7__GPIO4_IO06    0x17059
-				MX6SL_PAD_SD2_DAT7__GPIO5_IO00    0x17059
-				MX6SL_PAD_SD2_DAT6__GPIO4_IO29    0x17059
-				MX6SL_PAD_REF_CLK_32K__GPIO3_IO22 0x17059
-				MX6SL_PAD_FEC_TX_CLK__GPIO4_IO21  0x80000000
-				MX6SL_PAD_KEY_ROW5__GPIO4_IO03	  0x110b0
-				MX6SL_PAD_EPDC_VCOM0__GPIO2_IO03  0x80000000
-				MX6SL_PAD_EPDC_PWRSTAT__GPIO2_IO13 0x80000000
-				MX6SL_PAD_EPDC_PWRCTRL0__GPIO2_IO07 0x80000000
-				MX6SL_PAD_EPDC_PWRWAKEUP__GPIO2_IO14 0x80000000
-				MX6SL_PAD_EPDC_PWRINT__GPIO2_IO12 0x80000000
-				MX6SL_PAD_EPDC_PWRCTRL3__GPIO2_IO10 0x170b0
-				MX6SL_PAD_EPDC_PWRCTRL2__GPIO2_IO09 0x80000000
-				MX6SL_PAD_KEY_COL6__GPIO4_IO04    0x110b0
-				MX6SL_PAD_ECSPI2_MISO__GPIO4_IO14 0x17000
-				MX6SL_PAD_ECSPI2_MOSI__GPIO4_IO13 0x17000
-				MX6SL_PAD_ECSPI2_SS0__GPIO4_IO15  0x17000
-				MX6SL_PAD_FEC_RX_ER__GPIO4_IO19   0x1b0b0
-				MX6SL_PAD_LCD_RESET__GPIO2_IO19 0x1b0b0
-				MX6SL_PAD_KEY_COL4__GPIO4_IO00	0x80000000
-				MX6SL_PAD_KEY_COL5__GPIO4_IO02	0x80000000
-			>;
-		};
-
-		pinctrl_hog_sleep: hoggrp_sleep {
-			fsl,pins = <
-				MX6SL_PAD_KEY_ROW5__GPIO4_IO03	  0x3080
-				MX6SL_PAD_KEY_COL6__GPIO4_IO04 	  0x3080
-				MX6SL_PAD_LCD_RESET__GPIO2_IO19   0x3080
-			>;
-		};
-	};
-};
-
-&kpp {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&pinctrl_kpp_1>;
-	pinctrl-1 = <&pinctrl_kpp_1_sleep>;
-	linux,keymap = <
-			0x00000067      /* KEY_UP */
-			0x0001006c      /* KEY_DOWN */
-			0x0002001c      /* KEY_ENTER */
-			0x01000066      /* KEY_HOME */
-			0x0101006a      /* KEY_RIGHT */
-			0x01020069      /* KEY_LEFT */
-			0x02000072      /* KEY_VOLUMEDOWN */
-			0x02010073      /* KEY_VOLUMEUP */
-		>;
-        status = "okay";
-};
-
-&lcdif {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_lcdif_dat_0
-		     &pinctrl_lcdif_ctrl_0>;
-	lcd-supply = <&reg_lcd_3v3>;
-	display = <&display>;
-	status = "okay";
-
-	display: display {
-		bits-per-pixel = <16>;
-		bus-width = <24>;
-
-		display-timings {
-			native-mode = <&timing0>;
-			timing0: timing0 {
-				clock-frequency = <33500000>;
-				hactive = <800>;
-				vactive = <480>;
-				hback-porch = <89>;
-				hfront-porch = <164>;
-				vback-porch = <23>;
-				vfront-porch = <10>;
-				hsync-len = <10>;
-				vsync-len = <10>;
-				hsync-active = <0>;
-				vsync-active = <0>;
-				de-active = <1>;
-				pixelclk-active = <0>;
-			};
-		};
-	};
-};
-
-&pwm1 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&pinctrl_pwm1_0>;
-	pinctrl-1 = <&pinctrl_pwm1_0_sleep>;
-	status = "okay";
-};
-
-&pxp {
-	status = "okay";
-};
-
-&spdif {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_spdif_1>;
-	status = "okay";
-};
-
-&ssi2 {
-	fsl,mode = "i2s-slave";
-	status = "okay";
-};
-
-&uart1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_uart1_1>;
-	status = "okay";
-};
-
-&usbotg1 {
-	vbus-supply = <&reg_usb_otg1_vbus>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usbotg1_1>;
-	disable-over-current;
-	imx6-usb-charger-detection;
-	status = "okay";
-};
-
-&usbotg2 {
-	vbus-supply = <&reg_usb_otg2_vbus>;
-	dr_mode = "host";
-	disable-over-current;
-	status = "okay";
-};
-
-&usdhc1 {
-	pinctrl-names = "default", "state_100mhz", "state_200mhz";
-	pinctrl-0 = <&pinctrl_usdhc1_1>;
-	pinctrl-1 = <&pinctrl_usdhc1_1_100mhz>;
-	pinctrl-2 = <&pinctrl_usdhc1_1_200mhz>;
-	bus-width = <8>;
-	cd-gpios = <&gpio4 7 0>;
-	wp-gpios = <&gpio4 6 0>;
-	keep-power-in-suspend;
-	enable-sdio-wakeup;
-	status = "okay";
-};
-
-&usdhc2 {
-	pinctrl-names = "default", "state_100mhz", "state_200mhz";
-	pinctrl-0 = <&pinctrl_usdhc2_1>;
-	pinctrl-1 = <&pinctrl_usdhc2_1_100mhz>;
-	pinctrl-2 = <&pinctrl_usdhc2_1_200mhz>;
-	cd-gpios = <&gpio5 0 0>;
-	wp-gpios = <&gpio4 29 0>;
-	keep-power-in-suspend;
-	enable-sdio-wakeup;
-	status = "okay";
-};
-
-&usdhc3 {
-	pinctrl-names = "default", "state_100mhz", "state_200mhz";
-	pinctrl-0 = <&pinctrl_usdhc3_1>;
-	pinctrl-1 = <&pinctrl_usdhc3_1_100mhz>;
-	pinctrl-2 = <&pinctrl_usdhc3_1_200mhz>;
-	cd-gpios = <&gpio3 22 0>;
-	keep-power-in-suspend;
-	enable-sdio-wakeup;
-	status = "okay";
 };
diff --git a/arch/arm/mach-imx/cpuidle-imx6q.c b/arch/arm/mach-imx/cpuidle-imx6q.c
index d74d0ce..9ffbd34 100644
--- a/arch/arm/mach-imx/cpuidle-imx6q.c
+++ b/arch/arm/mach-imx/cpuidle-imx6q.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -65,9 +65,6 @@ static struct cpuidle_driver imx6q_cpuidle_driver = {
 
 int __init imx6q_cpuidle_init(void)
 {
-	/* Need to enable SCU standby for entering WAIT modes */
-	imx_scu_standby_enable();
-
 	/* Set cache lpm bit for reliable WAIT mode support */
 	imx6_set_cache_lpm_in_wait(true);
 
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 9734327..25e987c 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2013 Freescale Semiconductor, Inc.
+ * Copyright 2011-2014 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -90,7 +90,8 @@ static void imx_disp_clk(bool enable)
 
 static void imx_gpc_dispmix_on(void)
 {
-	if (cpu_is_imx6sl()) {
+	if (cpu_is_imx6sl() &&
+		imx_get_soc_revision() >= IMX_CHIP_REVISION_1_2) {
 		imx_disp_clk(true);
 
 		writel_relaxed(0x0, gpc_base + GPC_PGC_DISP_PGCR_OFFSET);
@@ -105,7 +106,8 @@ static void imx_gpc_dispmix_on(void)
 
 static void imx_gpc_dispmix_off(void)
 {
-	if (cpu_is_imx6sl()) {
+	if (cpu_is_imx6sl() &&
+		imx_get_soc_revision() >= IMX_CHIP_REVISION_1_2) {
 		imx_disp_clk(true);
 
 		writel_relaxed(0xFFFFFFFF,
diff --git a/arch/arm/mach-imx/platsmp.c b/arch/arm/mach-imx/platsmp.c
index c6e1ab5..d2fa7ec 100644
--- a/arch/arm/mach-imx/platsmp.c
+++ b/arch/arm/mach-imx/platsmp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011-2014 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -77,6 +77,8 @@ static void __init imx_smp_init_cpus(void)
 void imx_smp_prepare(void)
 {
 	scu_enable(scu_base);
+	/* Need to enable SCU standby for entering WAIT mode */
+	imx_scu_standby_enable();
 }
 
 static void __init imx_smp_prepare_cpus(unsigned int max_cpus)
diff --git a/arch/arm/mach-imx/pm-imx6.c b/arch/arm/mach-imx/pm-imx6.c
index de46b87..587cc7e 100644
--- a/arch/arm/mach-imx/pm-imx6.c
+++ b/arch/arm/mach-imx/pm-imx6.c
@@ -73,6 +73,8 @@ static int (*suspend_in_iram_fn)(void *iram_vbase,
 	unsigned long iram_pbase, unsigned int cpu_type);
 static unsigned int cpu_type;
 static void __iomem *ccm_base;
+static unsigned long dcr;
+static unsigned long pcr;
 
 unsigned long save_ttbr1(void)
 {
@@ -111,6 +113,34 @@ void imx6_set_cache_lpm_in_wait(bool enable)
 	}
 }
 
+static void imx6_save_cpu_arch_regs(void)
+{
+	/* Save the Diagnostic Control Register. */
+	asm volatile(
+		"mrc p15, 0, %0, c15, c0, 1\n"
+	: "=r" (dcr)
+	);
+	/* Save the Power Control Register. */
+	asm volatile(
+		"mrc p15, 0, %0, c15, c0, 0\n"
+	: "=r" (pcr)
+	);
+}
+
+static void imx6_restore_cpu_arch_regs(void)
+{
+	/* Restore the diagnostic Control Register. */
+	asm volatile(
+		"mcr p15, 0, %0, c15, c0, 1\n"
+	: : "r" (dcr)
+	);
+	/* Restore the Power Control Register. */
+	asm volatile(
+		"mcr p15, 0, %0, c15, c0, 0\n"
+	: : "r" (pcr)
+	);
+}
+
 static void imx6_enable_rbc(bool enable)
 {
 	u32 val;
@@ -290,8 +320,14 @@ static int imx6_pm_enter(suspend_state_t state)
 		imx_gpc_pre_suspend(true);
 		imx_anatop_pre_suspend();
 		imx_set_cpu_jump(0, v7_cpu_resume);
+
+		imx6_save_cpu_arch_regs();
+
 		/* Zzz ... */
 		cpu_suspend(0, imx6_suspend_finish);
+
+		imx6_restore_cpu_arch_regs();
+
 		if (!cpu_is_imx6sl())
 			imx_smp_prepare();
 		imx_anatop_post_resume();
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 1339404..5b64f2c 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -305,12 +305,12 @@ config REGULATOR_PCF50633
 	 on PCF50633
 
 config REGULATOR_PFUZE100
-	tristate "Support regulators on Freescale PFUZE100 PMIC"
+	tristate "Freescale PFUZE100/PFUZE200 regulator driver"
 	depends on I2C
 	select REGMAP_I2C
 	help
-	  Say y here to support the regulators found on the Freescale PFUZE100
-	  PMIC.
+	  Say y here to support the regulators found on the Freescale
+	  PFUZE100/PFUZE200 PMIC.
 
 config REGULATOR_RC5T583
 	tristate "RICOH RC5T583 Power regulators"
diff --git a/drivers/regulator/pfuze100-regulator.c b/drivers/regulator/pfuze100-regulator.c
index ba67b2c..b9c1b9a 100644
--- a/drivers/regulator/pfuze100-regulator.c
+++ b/drivers/regulator/pfuze100-regulator.c
@@ -38,7 +38,7 @@
 
 #define PFUZE100_DEVICEID	0x0
 #define PFUZE100_REVID		0x3
-#define PFUZE100_FABID		0x3
+#define PFUZE100_FABID		0x4
 
 #define PFUZE100_SW1ABVOL	0x20
 #define PFUZE100_SW1CVOL	0x2e
@@ -56,6 +56,8 @@
 #define PFUZE100_VGEN5VOL	0x70
 #define PFUZE100_VGEN6VOL	0x71
 
+enum chips { PFUZE100, PFUZE200 };
+
 struct pfuze_regulator {
 	struct regulator_desc desc;
 	unsigned char stby_reg;
@@ -63,6 +65,7 @@ struct pfuze_regulator {
 };
 
 struct pfuze_chip {
+	int	chip_id;
 	struct regmap *regmap;
 	struct device *dev;
 	struct pfuze_regulator regulator_descs[PFUZE100_MAX_REGULATOR];
@@ -78,14 +81,16 @@ static const int pfuze100_vsnvs[] = {
 };
 
 static const struct i2c_device_id pfuze_device_id[] = {
-	{.name = "pfuze100"},
-	{},
+	{.name = "pfuze100", .driver_data = PFUZE100},
+	{.name = "pfuze200", .driver_data = PFUZE200},
+	{ }
 };
 MODULE_DEVICE_TABLE(i2c, pfuze_device_id);
 
 static const struct of_device_id pfuze_dt_ids[] = {
-	{ .compatible = "fsl,pfuze100" },
-	{},
+	{ .compatible = "fsl,pfuze100", .data = (void *)PFUZE100},
+	{ .compatible = "fsl,pfuze200", .data = (void *)PFUZE200},
+	{ }
 };
 MODULE_DEVICE_TABLE(of, pfuze_dt_ids);
 
@@ -139,14 +144,14 @@ static struct regulator_ops pfuze100_swb_regulator_ops = {
 
 };
 
-#define PFUZE100_FIXED_REG(_name, base, voltage)	\
-	[PFUZE100_ ## _name] = {	\
+#define PFUZE100_FIXED_REG(_chip, _name, base, voltage)	\
+	[_chip ## _ ## _name] = {	\
 		.desc = {	\
 			.name = #_name,	\
 			.n_voltages = 1,	\
 			.ops = &pfuze100_fixed_regulator_ops,	\
 			.type = REGULATOR_VOLTAGE,	\
-			.id = PFUZE100_ ## _name,	\
+			.id = _chip ## _ ## _name,	\
 			.owner = THIS_MODULE,	\
 			.min_uV = (voltage),	\
 			.enable_reg = (base),	\
@@ -154,14 +159,14 @@ static struct regulator_ops pfuze100_swb_regulator_ops = {
 		},	\
 	}
 
-#define PFUZE100_SW_REG(_name, base, min, max, step)	\
-	[PFUZE100_ ## _name] = {	\
+#define PFUZE100_SW_REG(_chip, _name, base, min, max, step)	\
+	[_chip ## _ ## _name] = {	\
 		.desc = {	\
 			.name = #_name,\
 			.n_voltages = ((max) - (min)) / (step) + 1,	\
 			.ops = &pfuze100_sw_regulator_ops,	\
 			.type = REGULATOR_VOLTAGE,	\
-			.id = PFUZE100_ ## _name,	\
+			.id = _chip ## _ ## _name,	\
 			.owner = THIS_MODULE,	\
 			.min_uV = (min),	\
 			.uV_step = (step),	\
@@ -172,14 +177,14 @@ static struct regulator_ops pfuze100_swb_regulator_ops = {
 		.stby_mask = 0x3f,	\
 	}
 
-#define PFUZE100_SWB_REG(_name, base, mask, voltages)	\
-	[PFUZE100_ ## _name] = {	\
+#define PFUZE100_SWB_REG(_chip, _name, base, mask, voltages)	\
+	[_chip ## _ ##  _name] = {	\
 		.desc = {	\
 			.name = #_name,	\
 			.n_voltages = ARRAY_SIZE(voltages),	\
 			.ops = &pfuze100_swb_regulator_ops,	\
 			.type = REGULATOR_VOLTAGE,	\
-			.id = PFUZE100_ ## _name,	\
+			.id = _chip ## _ ## _name,	\
 			.owner = THIS_MODULE,	\
 			.volt_table = voltages,	\
 			.vsel_reg = (base),	\
@@ -187,14 +192,14 @@ static struct regulator_ops pfuze100_swb_regulator_ops = {
 		},	\
 	}
 
-#define PFUZE100_VGEN_REG(_name, base, min, max, step)	\
-	[PFUZE100_ ## _name] = {	\
+#define PFUZE100_VGEN_REG(_chip, _name, base, min, max, step)	\
+	[_chip ## _ ## _name] = {	\
 		.desc = {	\
 			.name = #_name,	\
 			.n_voltages = ((max) - (min)) / (step) + 1,	\
 			.ops = &pfuze100_ldo_regulator_ops,	\
 			.type = REGULATOR_VOLTAGE,	\
-			.id = PFUZE100_ ## _name,	\
+			.id = _chip ## _ ## _name,	\
 			.owner = THIS_MODULE,	\
 			.min_uV = (min),	\
 			.uV_step = (step),	\
@@ -207,25 +212,45 @@ static struct regulator_ops pfuze100_swb_regulator_ops = {
 		.stby_mask = 0x20,	\
 	}
 
+/* PFUZE100 */
 static struct pfuze_regulator pfuze100_regulators[] = {
-	PFUZE100_SW_REG(SW1AB, PFUZE100_SW1ABVOL, 300000, 1875000, 25000),
-	PFUZE100_SW_REG(SW1C, PFUZE100_SW1CVOL, 300000, 1875000, 25000),
-	PFUZE100_SW_REG(SW2, PFUZE100_SW2VOL, 400000, 1975000, 25000),
-	PFUZE100_SW_REG(SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),
-	PFUZE100_SW_REG(SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),
-	PFUZE100_SW_REG(SW4, PFUZE100_SW4VOL, 400000, 1975000, 25000),
-	PFUZE100_SWB_REG(SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),
-	PFUZE100_SWB_REG(VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),
-	PFUZE100_FIXED_REG(VREFDDR, PFUZE100_VREFDDRCON, 750000),
-	PFUZE100_VGEN_REG(VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),
-	PFUZE100_VGEN_REG(VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),
-	PFUZE100_VGEN_REG(VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),
-	PFUZE100_VGEN_REG(VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),
-	PFUZE100_VGEN_REG(VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),
-	PFUZE100_VGEN_REG(VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),
+	PFUZE100_SW_REG(PFUZE100, SW1AB, PFUZE100_SW1ABVOL, 300000, 1875000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW1C, PFUZE100_SW1CVOL, 300000, 1875000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW2, PFUZE100_SW2VOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW4, PFUZE100_SW4VOL, 400000, 1975000, 25000),
+	PFUZE100_SWB_REG(PFUZE100, SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),
+	PFUZE100_SWB_REG(PFUZE100, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),
+	PFUZE100_FIXED_REG(PFUZE100, VREFDDR, PFUZE100_VREFDDRCON, 750000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),
+};
+
+static struct pfuze_regulator pfuze200_regulators[] = {
+	PFUZE100_SW_REG(PFUZE200, SW1AB, PFUZE100_SW1ABVOL, 300000, 1875000, 25000),
+	PFUZE100_SW_REG(PFUZE200, SW2, PFUZE100_SW2VOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE200, SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE200, SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),
+	PFUZE100_SWB_REG(PFUZE200, SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),
+	PFUZE100_SWB_REG(PFUZE200, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),
+	PFUZE100_FIXED_REG(PFUZE200, VREFDDR, PFUZE100_VREFDDRCON, 750000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),
 };
 
+static struct pfuze_regulator *pfuze_regulators;
+
 #ifdef CONFIG_OF
+/* PFUZE100 */
 static struct of_regulator_match pfuze100_matches[] = {
 	{ .name = "sw1ab",	},
 	{ .name = "sw1c",	},
@@ -244,24 +269,56 @@ static struct of_regulator_match pfuze100_matches[] = {
 	{ .name = "vgen6",	},
 };
 
+/* PFUZE200 */
+static struct of_regulator_match pfuze200_matches[] = {
+
+	{ .name = "sw1ab",	},
+	{ .name = "sw2",	},
+	{ .name = "sw3a",	},
+	{ .name = "sw3b",	},
+	{ .name = "swbst",	},
+	{ .name = "vsnvs",	},
+	{ .name = "vrefddr",	},
+	{ .name = "vgen1",	},
+	{ .name = "vgen2",	},
+	{ .name = "vgen3",	},
+	{ .name = "vgen4",	},
+	{ .name = "vgen5",	},
+	{ .name = "vgen6",	},
+};
+
+static struct of_regulator_match *pfuze_matches;
+
 static int pfuze_parse_regulators_dt(struct pfuze_chip *chip)
 {
 	struct device *dev = chip->dev;
 	struct device_node *np, *parent;
 	int ret;
 
-	np = of_node_get(dev->parent->of_node);
+	np = of_node_get(dev->of_node);
 	if (!np)
 		return 0;
 
-	parent = of_find_node_by_name(np, "regulators");
+	parent = of_get_child_by_name(np, "regulators");
 	if (!parent) {
 		dev_err(dev, "regulators node not found\n");
 		return -EINVAL;
 	}
 
-	ret = of_regulator_match(dev, parent, pfuze100_matches,
-				 ARRAY_SIZE(pfuze100_matches));
+	switch (chip->chip_id) {
+	case PFUZE200:
+		pfuze_matches = pfuze200_matches;
+		ret = of_regulator_match(dev, parent, pfuze200_matches,
+					 ARRAY_SIZE(pfuze200_matches));
+		break;
+
+	case PFUZE100:
+	default:
+		pfuze_matches = pfuze100_matches;
+		ret = of_regulator_match(dev, parent, pfuze100_matches,
+					 ARRAY_SIZE(pfuze100_matches));
+		break;
+	}
 
 	of_node_put(parent);
 	if (ret < 0) {
@@ -275,12 +332,12 @@ static int pfuze_parse_regulators_dt(struct pfuze_chip *chip)
 
 static inline struct regulator_init_data *match_init_data(int index)
 {
-	return pfuze100_matches[index].init_data;
+	return pfuze_matches[index].init_data;
 }
 
 static inline struct device_node *match_of_node(int index)
 {
-	return pfuze100_matches[index].of_node;
+	return pfuze_matches[index].of_node;
 }
 #else
 static int pfuze_parse_regulators_dt(struct pfuze_chip *chip)
@@ -308,7 +365,8 @@ static int pfuze_identify(struct pfuze_chip *pfuze_chip)
 	if (ret)
 		return ret;
 
-	if (value & 0x0f) {
+	if ((value & 0x0f) != pfuze_chip->chip_id) {
+		/* device id NOT match with your setting */
 		dev_warn(pfuze_chip->dev, "Illegal ID: %x\n", value);
 		return -ENODEV;
 	}
@@ -344,17 +402,31 @@ static int pfuze100_regulator_probe(struct i2c_client *client,
 	    dev_get_platdata(&client->dev);
 	struct regulator_config config = { };
 	int i, ret;
+	const struct of_device_id *match;
+	u32 regulator_num;
+	u32 sw_check_start, sw_check_end;
 
 	pfuze_chip = devm_kzalloc(&client->dev, sizeof(*pfuze_chip),
 			GFP_KERNEL);
 	if (!pfuze_chip)
 		return -ENOMEM;
 
-	i2c_set_clientdata(client, pfuze_chip);
-
-	memcpy(pfuze_chip->regulator_descs, pfuze100_regulators,
-		sizeof(pfuze_chip->regulator_descs));
+	if (client->dev.of_node) {
+		match = of_match_device(of_match_ptr(pfuze_dt_ids),
+				&client->dev);
+		if (!match) {
+			dev_err(&client->dev, "Error: No device match found\n");
+			return -ENODEV;
+		}
+		pfuze_chip->chip_id = (int)(long)match->data;
+	} else if (id) {
+		pfuze_chip->chip_id = id->driver_data;
+	} else {
+		dev_err(&client->dev, "No dts match or id table match found\n");
+		return -ENODEV;
+	}
 
+	i2c_set_clientdata(client, pfuze_chip);
 	pfuze_chip->dev = &client->dev;
 
 	pfuze_chip->regmap = devm_regmap_init_i2c(client, &pfuze_regmap_config);
@@ -371,11 +443,34 @@ static int pfuze100_regulator_probe(struct i2c_client *client,
 		return ret;
 	}
 
+	/* use the right regulators after identify the right device */
+	switch (pfuze_chip->chip_id) {
+	case PFUZE200:
+		pfuze_regulators = pfuze200_regulators;
+		regulator_num = ARRAY_SIZE(pfuze200_regulators);
+		sw_check_start = PFUZE200_SW2;
+		sw_check_end = PFUZE200_SW3B;
+		break;
+
+	case PFUZE100:
+	default:
+		pfuze_regulators = pfuze100_regulators;
+		regulator_num = ARRAY_SIZE(pfuze100_regulators);
+		sw_check_start = PFUZE100_SW2;
+		sw_check_end = PFUZE100_SW4;
+		break;
+	}
+	dev_info(&client->dev, "pfuze%s found.\n",
+		(pfuze_chip->chip_id == PFUZE100) ? "100" : "200");
+
+	memcpy(pfuze_chip->regulator_descs, pfuze_regulators,
+		sizeof(pfuze_chip->regulator_descs));
+
 	ret = pfuze_parse_regulators_dt(pfuze_chip);
 	if (ret)
 		return ret;
 
-	for (i = 0; i < PFUZE100_MAX_REGULATOR; i++) {
+	for (i = 0; i < regulator_num; i++) {
 		struct regulator_init_data *init_data;
 		struct regulator_desc *desc;
 		int val;
@@ -388,7 +483,7 @@ static int pfuze100_regulator_probe(struct i2c_client *client,
 			init_data = match_init_data(i);
 
 		/* SW2~SW4 high bit check and modify the voltage value table */
-		if (i > PFUZE100_SW1C && i < PFUZE100_SWBST) {
+		if (i >= sw_check_start && i <= sw_check_end) {
 			regmap_read(pfuze_chip->regmap, desc->vsel_reg, &val);
 			if (val & 0x40) {
 				desc->min_uV = 800000;
@@ -440,6 +535,6 @@ static struct i2c_driver pfuze_driver = {
 module_i2c_driver(pfuze_driver);
 
 MODULE_AUTHOR("Robin Gong <b38343@freescale.com>");
-MODULE_DESCRIPTION("Regulator Driver for Freescale PFUZE100 PMIC");
+MODULE_DESCRIPTION("Regulator Driver for Freescale PFUZE100/PFUZE200 PMIC");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("i2c:pfuze100-regulator");
diff --git a/include/linux/regulator/pfuze100.h b/include/linux/regulator/pfuze100.h
index 65d550b..364f7a7 100644
--- a/include/linux/regulator/pfuze100.h
+++ b/include/linux/regulator/pfuze100.h
@@ -35,6 +35,20 @@
 #define PFUZE100_VGEN6		14
 #define PFUZE100_MAX_REGULATOR	15
 
+#define PFUZE200_SW1AB		0
+#define PFUZE200_SW2		1
+#define PFUZE200_SW3A		2
+#define PFUZE200_SW3B		3
+#define PFUZE200_SWBST		4
+#define PFUZE200_VSNVS		5
+#define PFUZE200_VREFDDR	6
+#define PFUZE200_VGEN1		7
+#define PFUZE200_VGEN2		8
+#define PFUZE200_VGEN3		9
+#define PFUZE200_VGEN4		10
+#define PFUZE200_VGEN5		11
+#define PFUZE200_VGEN6		12
+
 struct regulator_init_data;
 
 struct pfuze_regulator_platform_data {
-- 
1.9.1

